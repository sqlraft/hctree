/*
** 2022 November 10
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
*/

#include "sqliteInt.h"

#ifndef SQLITE_AMALGAMATION
struct BtCursor {
  const BtCursorMethods *pMethods;
};

struct Btree {
  const BtreeMethods *pMethods;
};
#endif

int sqlite3HctBtreeCursorSize(void);
int sqlite3HctBtreeOpen(sqlite3_vfs*, const char*, sqlite3*, Btree**, int, int);
int sqlite3HctBtreeSchemaLoaded(Btree*);

int sqlite3StockBtreeCursorSize(void);
int sqlite3StockBtreeOpen(sqlite3_vfs*, const char*, sqlite3*, Btree**,int,int);

int sqlite3StockBtreePragma(Btree *p, char **a){
  return SQLITE_NOTFOUND;
}
void sqlite3StockBtreeCursorDir(BtCursor *p, int a){
  /* no-op */
}


int sqlite3StockBtreeIdxDelete(BtCursor *p, UnpackedRecord *pRec){
  int rc = SQLITE_OK;
  int res = 0;

  rc = sqlite3BtreeIndexMoveto(p, pRec, &res);
  if( rc==SQLITE_OK && res==0 ){
    rc = sqlite3BtreeDelete(p, BTREE_AUXDELETE);
  }

  return rc;
}

#ifndef SQLITE_DEBUG
int sqlite3StockBtreeCursorIsValid(BtCursor *pCursor){
  return 1;
}
sqlite3_uint64 sqlite3StockBtreeSeekCount(Btree *p){
  return 0;
}
#endif

#if SQLITE_MAX_MMAP_SIZE<=0
int sqlite3HctBtreeSetMmapLimit(Btree *p, sqlite3_int64 szMmap){
  assert( 0 );
  return SQLITE_OK;
}
int sqlite3StockBtreeSetMmapLimit(Btree *p, sqlite3_int64 szMmap){
  assert( 0 );
  return SQLITE_OK;
}
#endif

/* BEGIN_HCT_MKBTREEWRAPPER_TCL_CODE */
/******************************************************************
** GENERATED CODE - DO NOT EDIT!
**
** Code generated by tool/hct_mkbtreewrapper.tcl
*/
struct BtCursorMethods {
  int(*xBtreeNext)(BtCursor*, int);
  int(*xBtreeCursorHasMoved)(BtCursor*);
  void(*xBtreeClearCursor)(BtCursor*);
  int(*xBtreeCursorRestore)(BtCursor*, int*);
  void(*xBtreeCursorHintFlags)(BtCursor*, unsigned);
  int(*xBtreeCloseCursor)(BtCursor*);
  int(*xBtreeCursorIsValid)(BtCursor*);
  int(*xBtreeCursorIsValidNN)(BtCursor*);
  i64(*xBtreeIntegerKey)(BtCursor*);
  void(*xBtreeCursorPin)(BtCursor*);
  void(*xBtreeCursorUnpin)(BtCursor*);
  u32(*xBtreePayloadSize)(BtCursor*);
  sqlite3_int64(*xBtreeMaxRecordSize)(BtCursor*);
  int(*xBtreePayload)(BtCursor*, u32, u32, void*);
  int(*xBtreePayloadChecked)(BtCursor*, u32, u32, void *);
  const void *(*xBtreePayloadFetch)(BtCursor*, u32*);
  int(*xBtreeFirst)(BtCursor*, int*);
  int(*xBtreeLast)(BtCursor*, int*);
  int(*xBtreeTableMoveto)(BtCursor*, i64, int, int*);
  int(*xBtreeIndexMoveto)(BtCursor*, UnpackedRecord*, int*);
  void(*xBtreeCursorDir)(BtCursor*, int);
  int(*xBtreeEof)(BtCursor*);
  i64(*xBtreeRowCountEst)(BtCursor*);
  int(*xBtreePrevious)(BtCursor*, int);
  int(*xBtreeInsert)(BtCursor*, const BtreePayload*, int, int);
  int(*xBtreeDelete)(BtCursor*, u8);
  int(*xBtreeIdxDelete)(BtCursor*, UnpackedRecord*);
  int(*xBtreePutData)(BtCursor*, u32, u32, void*);
  void(*xBtreeIncrblobCursor)(BtCursor*);
  int(*xBtreeCursorHasHint)(BtCursor*, unsigned int);
  int(*xBtreeTransferRow)(BtCursor*, BtCursor*, i64);
  int(*xBtreeClearTableOfCursor)(BtCursor*);
  int(*xBtreeCount)(sqlite3*, BtCursor*, i64*);
};
struct BtreeMethods {
  BtCursorMethods const *pCsrMethods;
  int(*xBtreeCursor)(Btree*, Pgno, int, struct KeyInfo*, BtCursor*);
  sqlite3_uint64(*xBtreeSeekCount)(Btree*);
  Pgno(*xBtreeLastPage)(Btree*);
  int(*xBtreeClose)(Btree*);
  int(*xBtreeSetCacheSize)(Btree*, int);
  int(*xBtreeSetSpillSize)(Btree*, int);
  int(*xBtreeSetMmapLimit)(Btree*, sqlite3_int64);
  int(*xBtreeSetPagerFlags)(Btree*, unsigned);
  int(*xBtreeSetPageSize)(Btree*, int, int, int);
  int(*xBtreeGetPageSize)(Btree*);
  int(*xBtreeGetReserveNoMutex)(Btree*);
  int(*xBtreeGetRequestedReserve)(Btree*);
  Pgno(*xBtreeMaxPageCount)(Btree*, Pgno);
  int(*xBtreeSecureDelete)(Btree*, int);
  int(*xBtreeSetAutoVacuum)(Btree*, int);
  int(*xBtreeGetAutoVacuum)(Btree*);
  int(*xBtreeNewDb)(Btree*);
  int(*xBtreeBeginTrans)(Btree*, int, int*);
  int(*xBtreeIncrVacuum)(Btree*);
  int(*xBtreeCommitPhaseOne)(Btree*, const char*);
  int(*xBtreeCommitPhaseTwo)(Btree*, int);
  int(*xBtreeCommit)(Btree*);
  int(*xBtreeTripAllCursors)(Btree*, int, int);
  int(*xBtreeRollback)(Btree*, int, int);
  int(*xBtreeBeginStmt)(Btree*, int);
  int(*xBtreeSavepoint)(Btree*, int, int);
  int(*xBtreeCreateTable)(Btree*, Pgno*, int);
  int(*xBtreeClearTable)(Btree*, int, i64*);
  int(*xBtreeDropTable)(Btree*, int, int*);
  void(*xBtreeGetMeta)(Btree*, int, u32*);
  int(*xBtreeUpdateMeta)(Btree*, int, u32);
  int(*xBtreePragma)(Btree*, char**);
  Pager *(*xBtreePager)(Btree*);
  const char *(*xBtreeGetFilename)(Btree*);
  const char *(*xBtreeGetJournalname)(Btree*);
  int(*xBtreeTxnState)(Btree*);
  int(*xBtreeIsInBackup)(Btree*);
  void *(*xBtreeSchema)(Btree*, int, void(*)(void *));
  int(*xBtreeSchemaLocked)(Btree*);
  int(*xBtreeIsReadonly)(Btree*);
  int(*xBtreeSetVersion)(Btree*, int);
  int(*xBtreeIntegrityCheck)(sqlite3*, Btree*, Pgno*, Mem*, int, int, int*, char**);
  int(*xBtreeCheckpoint)(Btree*, int, int *, int *);
  int(*xBtreeExclusiveLock)(Btree*);
};
int sqlite3BtreeNext(BtCursor *p, int a){
  return p->pMethods->xBtreeNext(p, a);
}
void sqlite3BtreeClearCursor(BtCursor *p){
  p->pMethods->xBtreeClearCursor(p);
}
int sqlite3BtreeCursorRestore(BtCursor *p, int *a){
  return p->pMethods->xBtreeCursorRestore(p, a);
}
void sqlite3BtreeCursorHintFlags(BtCursor *p, unsigned a){
  p->pMethods->xBtreeCursorHintFlags(p, a);
}
int sqlite3BtreeCursorIsValid(BtCursor *p){
  return p->pMethods->xBtreeCursorIsValid(p);
}
int sqlite3BtreeCursorIsValidNN(BtCursor *p){
  return p->pMethods->xBtreeCursorIsValidNN(p);
}
i64 sqlite3BtreeIntegerKey(BtCursor *p){
  return p->pMethods->xBtreeIntegerKey(p);
}
void sqlite3BtreeCursorPin(BtCursor *p){
  p->pMethods->xBtreeCursorPin(p);
}
void sqlite3BtreeCursorUnpin(BtCursor *p){
  p->pMethods->xBtreeCursorUnpin(p);
}
u32 sqlite3BtreePayloadSize(BtCursor *p){
  return p->pMethods->xBtreePayloadSize(p);
}
sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor *p){
  return p->pMethods->xBtreeMaxRecordSize(p);
}
int sqlite3BtreePayload(BtCursor *p, u32 a, u32 b, void *c){
  return p->pMethods->xBtreePayload(p, a, b, c);
}
int sqlite3BtreePayloadChecked(BtCursor *p, u32 a, u32 b, void *c){
  return p->pMethods->xBtreePayloadChecked(p, a, b, c);
}
const void * sqlite3BtreePayloadFetch(BtCursor *p, u32 *a){
  return p->pMethods->xBtreePayloadFetch(p, a);
}
int sqlite3BtreeFirst(BtCursor *p, int *a){
  return p->pMethods->xBtreeFirst(p, a);
}
int sqlite3BtreeLast(BtCursor *p, int *a){
  return p->pMethods->xBtreeLast(p, a);
}
int sqlite3BtreeTableMoveto(BtCursor *p, i64 a, int b, int *c){
  return p->pMethods->xBtreeTableMoveto(p, a, b, c);
}
int sqlite3BtreeIndexMoveto(BtCursor *p, UnpackedRecord *a, int *b){
  return p->pMethods->xBtreeIndexMoveto(p, a, b);
}
void sqlite3BtreeCursorDir(BtCursor *p, int a){
  p->pMethods->xBtreeCursorDir(p, a);
}
int sqlite3BtreeEof(BtCursor *p){
  return p->pMethods->xBtreeEof(p);
}
i64 sqlite3BtreeRowCountEst(BtCursor *p){
  return p->pMethods->xBtreeRowCountEst(p);
}
int sqlite3BtreePrevious(BtCursor *p, int a){
  return p->pMethods->xBtreePrevious(p, a);
}
int sqlite3BtreeInsert(BtCursor *p, const BtreePayload *a, int b, int c){
  return p->pMethods->xBtreeInsert(p, a, b, c);
}
int sqlite3BtreeDelete(BtCursor *p, u8 a){
  return p->pMethods->xBtreeDelete(p, a);
}
int sqlite3BtreeIdxDelete(BtCursor *p, UnpackedRecord *a){
  return p->pMethods->xBtreeIdxDelete(p, a);
}
int sqlite3BtreePutData(BtCursor *p, u32 a, u32 b, void *c){
  return p->pMethods->xBtreePutData(p, a, b, c);
}
void sqlite3BtreeIncrblobCursor(BtCursor *p){
  p->pMethods->xBtreeIncrblobCursor(p);
}
int sqlite3BtreeCursorHasHint(BtCursor *p, unsigned int a){
  return p->pMethods->xBtreeCursorHasHint(p, a);
}
int sqlite3BtreeTransferRow(BtCursor *p, BtCursor *a, i64 b){
  return p->pMethods->xBtreeTransferRow(p, a, b);
}
int sqlite3BtreeClearTableOfCursor(BtCursor *p){
  return p->pMethods->xBtreeClearTableOfCursor(p);
}
int sqlite3BtreeCount(sqlite3 *a, BtCursor *p, i64 *b){
  return p->pMethods->xBtreeCount(a, p, b);
}
Pgno sqlite3BtreeLastPage(Btree *p){
  return p->pMethods->xBtreeLastPage(p);
}
int sqlite3BtreeClose(Btree *p){
  return p->pMethods->xBtreeClose(p);
}
int sqlite3BtreeSetCacheSize(Btree *p, int a){
  return p->pMethods->xBtreeSetCacheSize(p, a);
}
int sqlite3BtreeSetSpillSize(Btree *p, int a){
  return p->pMethods->xBtreeSetSpillSize(p, a);
}
int sqlite3BtreeSetMmapLimit(Btree *p, sqlite3_int64 a){
  return p->pMethods->xBtreeSetMmapLimit(p, a);
}
int sqlite3BtreeSetPagerFlags(Btree *p, unsigned a){
  return p->pMethods->xBtreeSetPagerFlags(p, a);
}
int sqlite3BtreeSetPageSize(Btree *p, int a, int b, int c){
  return p->pMethods->xBtreeSetPageSize(p, a, b, c);
}
int sqlite3BtreeGetPageSize(Btree *p){
  return p->pMethods->xBtreeGetPageSize(p);
}
int sqlite3BtreeGetReserveNoMutex(Btree *p){
  return p->pMethods->xBtreeGetReserveNoMutex(p);
}
int sqlite3BtreeGetRequestedReserve(Btree *p){
  return p->pMethods->xBtreeGetRequestedReserve(p);
}
Pgno sqlite3BtreeMaxPageCount(Btree *p, Pgno a){
  return p->pMethods->xBtreeMaxPageCount(p, a);
}
int sqlite3BtreeSecureDelete(Btree *p, int a){
  if( p==0 ) return 0;
  return p->pMethods->xBtreeSecureDelete(p, a);
}
int sqlite3BtreeSetAutoVacuum(Btree *p, int a){
  return p->pMethods->xBtreeSetAutoVacuum(p, a);
}
int sqlite3BtreeGetAutoVacuum(Btree *p){
  return p->pMethods->xBtreeGetAutoVacuum(p);
}
int sqlite3BtreeNewDb(Btree *p){
  return p->pMethods->xBtreeNewDb(p);
}
int sqlite3BtreeBeginTrans(Btree *p, int a, int *b){
  return p->pMethods->xBtreeBeginTrans(p, a, b);
}
int sqlite3BtreeIncrVacuum(Btree *p){
  return p->pMethods->xBtreeIncrVacuum(p);
}
int sqlite3BtreeCommitPhaseOne(Btree *p, const char *a){
  return p->pMethods->xBtreeCommitPhaseOne(p, a);
}
int sqlite3BtreeCommitPhaseTwo(Btree *p, int a){
  return p->pMethods->xBtreeCommitPhaseTwo(p, a);
}
int sqlite3BtreeCommit(Btree *p){
  return p->pMethods->xBtreeCommit(p);
}
int sqlite3BtreeTripAllCursors(Btree *p, int a, int b){
  if( p==0 ) return 0;
  return p->pMethods->xBtreeTripAllCursors(p, a, b);
}
int sqlite3BtreeRollback(Btree *p, int a, int b){
  return p->pMethods->xBtreeRollback(p, a, b);
}
int sqlite3BtreeBeginStmt(Btree *p, int a){
  return p->pMethods->xBtreeBeginStmt(p, a);
}
int sqlite3BtreeSavepoint(Btree *p, int a, int b){
  if( p==0 ) return 0;
  return p->pMethods->xBtreeSavepoint(p, a, b);
}
int sqlite3BtreeCreateTable(Btree *p, Pgno *a, int b){
  return p->pMethods->xBtreeCreateTable(p, a, b);
}
int sqlite3BtreeClearTable(Btree *p, int a, i64 *b){
  return p->pMethods->xBtreeClearTable(p, a, b);
}
int sqlite3BtreeDropTable(Btree *p, int a, int *b){
  return p->pMethods->xBtreeDropTable(p, a, b);
}
void sqlite3BtreeGetMeta(Btree *p, int a, u32 *b){
  p->pMethods->xBtreeGetMeta(p, a, b);
}
int sqlite3BtreeUpdateMeta(Btree *p, int a, u32 b){
  return p->pMethods->xBtreeUpdateMeta(p, a, b);
}
int sqlite3BtreePragma(Btree *p, char* *a){
  if( p==0 ) return 0;
  return p->pMethods->xBtreePragma(p, a);
}
Pager * sqlite3BtreePager(Btree *p){
  return p->pMethods->xBtreePager(p);
}
const char * sqlite3BtreeGetFilename(Btree *p){
  return p->pMethods->xBtreeGetFilename(p);
}
const char * sqlite3BtreeGetJournalname(Btree *p){
  return p->pMethods->xBtreeGetJournalname(p);
}
int sqlite3BtreeTxnState(Btree *p){
  if( p==0 ) return 0;
  return p->pMethods->xBtreeTxnState(p);
}
int sqlite3BtreeIsInBackup(Btree *p){
  return p->pMethods->xBtreeIsInBackup(p);
}
void * sqlite3BtreeSchema(Btree *p, int a, void (*xFree)(void *)){
  return p->pMethods->xBtreeSchema(p, a, xFree);
}
int sqlite3BtreeSchemaLocked(Btree *p){
  return p->pMethods->xBtreeSchemaLocked(p);
}
int sqlite3BtreeIsReadonly(Btree *p){
  return p->pMethods->xBtreeIsReadonly(p);
}
int sqlite3BtreeSetVersion(Btree *p, int a){
  return p->pMethods->xBtreeSetVersion(p, a);
}
int sqlite3BtreeIntegrityCheck(sqlite3 *a, Btree *p, Pgno *b, Mem *c, int d, int e, int *f, char* *g){
  return p->pMethods->xBtreeIntegrityCheck(a, p, b, c, d, e, f, g);
}
int sqlite3BtreeCheckpoint(Btree *p, int a, int *b, int *c){
  if( p==0 ) return 0;
  return p->pMethods->xBtreeCheckpoint(p, a, b, c);
}
int sqlite3BtreeExclusiveLock(Btree *p){
  return p->pMethods->xBtreeExclusiveLock(p);
}
static const BtCursorMethods hct_btcursor_methods = {
  .xBtreeNext = sqlite3HctBtreeNext,
  .xBtreeCursorHasMoved = sqlite3HctBtreeCursorHasMoved,
  .xBtreeClearCursor = sqlite3HctBtreeClearCursor,
  .xBtreeCursorRestore = sqlite3HctBtreeCursorRestore,
  .xBtreeCursorHintFlags = sqlite3HctBtreeCursorHintFlags,
  .xBtreeCloseCursor = sqlite3HctBtreeCloseCursor,
  .xBtreeCursorIsValid = sqlite3HctBtreeCursorIsValid,
  .xBtreeCursorIsValidNN = sqlite3HctBtreeCursorIsValidNN,
  .xBtreeIntegerKey = sqlite3HctBtreeIntegerKey,
  .xBtreeCursorPin = sqlite3HctBtreeCursorPin,
  .xBtreeCursorUnpin = sqlite3HctBtreeCursorUnpin,
  .xBtreePayloadSize = sqlite3HctBtreePayloadSize,
  .xBtreeMaxRecordSize = sqlite3HctBtreeMaxRecordSize,
  .xBtreePayload = sqlite3HctBtreePayload,
  .xBtreePayloadChecked = sqlite3HctBtreePayloadChecked,
  .xBtreePayloadFetch = sqlite3HctBtreePayloadFetch,
  .xBtreeFirst = sqlite3HctBtreeFirst,
  .xBtreeLast = sqlite3HctBtreeLast,
  .xBtreeTableMoveto = sqlite3HctBtreeTableMoveto,
  .xBtreeIndexMoveto = sqlite3HctBtreeIndexMoveto,
  .xBtreeCursorDir = sqlite3HctBtreeCursorDir,
  .xBtreeEof = sqlite3HctBtreeEof,
  .xBtreeRowCountEst = sqlite3HctBtreeRowCountEst,
  .xBtreePrevious = sqlite3HctBtreePrevious,
  .xBtreeInsert = sqlite3HctBtreeInsert,
  .xBtreeDelete = sqlite3HctBtreeDelete,
  .xBtreeIdxDelete = sqlite3HctBtreeIdxDelete,
  .xBtreePutData = sqlite3HctBtreePutData,
  .xBtreeIncrblobCursor = sqlite3HctBtreeIncrblobCursor,
  .xBtreeCursorHasHint = sqlite3HctBtreeCursorHasHint,
  .xBtreeTransferRow = sqlite3HctBtreeTransferRow,
  .xBtreeClearTableOfCursor = sqlite3HctBtreeClearTableOfCursor,
  .xBtreeCount = sqlite3HctBtreeCount,
};
static const BtreeMethods hct_btree_methods = {
  .pCsrMethods = &hct_btcursor_methods,
  .xBtreeCursor = sqlite3HctBtreeCursor,
  .xBtreeSeekCount = sqlite3HctBtreeSeekCount,
  .xBtreeLastPage = sqlite3HctBtreeLastPage,
  .xBtreeClose = sqlite3HctBtreeClose,
  .xBtreeSetCacheSize = sqlite3HctBtreeSetCacheSize,
  .xBtreeSetSpillSize = sqlite3HctBtreeSetSpillSize,
  .xBtreeSetMmapLimit = sqlite3HctBtreeSetMmapLimit,
  .xBtreeSetPagerFlags = sqlite3HctBtreeSetPagerFlags,
  .xBtreeSetPageSize = sqlite3HctBtreeSetPageSize,
  .xBtreeGetPageSize = sqlite3HctBtreeGetPageSize,
  .xBtreeGetReserveNoMutex = sqlite3HctBtreeGetReserveNoMutex,
  .xBtreeGetRequestedReserve = sqlite3HctBtreeGetRequestedReserve,
  .xBtreeMaxPageCount = sqlite3HctBtreeMaxPageCount,
  .xBtreeSecureDelete = sqlite3HctBtreeSecureDelete,
  .xBtreeSetAutoVacuum = sqlite3HctBtreeSetAutoVacuum,
  .xBtreeGetAutoVacuum = sqlite3HctBtreeGetAutoVacuum,
  .xBtreeNewDb = sqlite3HctBtreeNewDb,
  .xBtreeBeginTrans = sqlite3HctBtreeBeginTrans,
  .xBtreeIncrVacuum = sqlite3HctBtreeIncrVacuum,
  .xBtreeCommitPhaseOne = sqlite3HctBtreeCommitPhaseOne,
  .xBtreeCommitPhaseTwo = sqlite3HctBtreeCommitPhaseTwo,
  .xBtreeCommit = sqlite3HctBtreeCommit,
  .xBtreeTripAllCursors = sqlite3HctBtreeTripAllCursors,
  .xBtreeRollback = sqlite3HctBtreeRollback,
  .xBtreeBeginStmt = sqlite3HctBtreeBeginStmt,
  .xBtreeSavepoint = sqlite3HctBtreeSavepoint,
  .xBtreeCreateTable = sqlite3HctBtreeCreateTable,
  .xBtreeClearTable = sqlite3HctBtreeClearTable,
  .xBtreeDropTable = sqlite3HctBtreeDropTable,
  .xBtreeGetMeta = sqlite3HctBtreeGetMeta,
  .xBtreeUpdateMeta = sqlite3HctBtreeUpdateMeta,
  .xBtreePragma = sqlite3HctBtreePragma,
  .xBtreePager = sqlite3HctBtreePager,
  .xBtreeGetFilename = sqlite3HctBtreeGetFilename,
  .xBtreeGetJournalname = sqlite3HctBtreeGetJournalname,
  .xBtreeTxnState = sqlite3HctBtreeTxnState,
  .xBtreeIsInBackup = sqlite3HctBtreeIsInBackup,
  .xBtreeSchema = sqlite3HctBtreeSchema,
  .xBtreeSchemaLocked = sqlite3HctBtreeSchemaLocked,
  .xBtreeIsReadonly = sqlite3HctBtreeIsReadonly,
  .xBtreeSetVersion = sqlite3HctBtreeSetVersion,
  .xBtreeIntegrityCheck = sqlite3HctBtreeIntegrityCheck,
  .xBtreeCheckpoint = sqlite3HctBtreeCheckpoint,
  .xBtreeExclusiveLock = sqlite3HctBtreeExclusiveLock,
};

static const BtCursorMethods stock_btcursor_methods = {
  .xBtreeNext = sqlite3StockBtreeNext,
  .xBtreeCursorHasMoved = sqlite3StockBtreeCursorHasMoved,
  .xBtreeClearCursor = sqlite3StockBtreeClearCursor,
  .xBtreeCursorRestore = sqlite3StockBtreeCursorRestore,
  .xBtreeCursorHintFlags = sqlite3StockBtreeCursorHintFlags,
  .xBtreeCloseCursor = sqlite3StockBtreeCloseCursor,
  .xBtreeCursorIsValid = sqlite3StockBtreeCursorIsValid,
  .xBtreeCursorIsValidNN = sqlite3StockBtreeCursorIsValidNN,
  .xBtreeIntegerKey = sqlite3StockBtreeIntegerKey,
  .xBtreeCursorPin = sqlite3StockBtreeCursorPin,
  .xBtreeCursorUnpin = sqlite3StockBtreeCursorUnpin,
  .xBtreePayloadSize = sqlite3StockBtreePayloadSize,
  .xBtreeMaxRecordSize = sqlite3StockBtreeMaxRecordSize,
  .xBtreePayload = sqlite3StockBtreePayload,
  .xBtreePayloadChecked = sqlite3StockBtreePayloadChecked,
  .xBtreePayloadFetch = sqlite3StockBtreePayloadFetch,
  .xBtreeFirst = sqlite3StockBtreeFirst,
  .xBtreeLast = sqlite3StockBtreeLast,
  .xBtreeTableMoveto = sqlite3StockBtreeTableMoveto,
  .xBtreeIndexMoveto = sqlite3StockBtreeIndexMoveto,
  .xBtreeCursorDir = sqlite3StockBtreeCursorDir,
  .xBtreeEof = sqlite3StockBtreeEof,
  .xBtreeRowCountEst = sqlite3StockBtreeRowCountEst,
  .xBtreePrevious = sqlite3StockBtreePrevious,
  .xBtreeInsert = sqlite3StockBtreeInsert,
  .xBtreeDelete = sqlite3StockBtreeDelete,
  .xBtreeIdxDelete = sqlite3StockBtreeIdxDelete,
  .xBtreePutData = sqlite3StockBtreePutData,
  .xBtreeIncrblobCursor = sqlite3StockBtreeIncrblobCursor,
  .xBtreeCursorHasHint = sqlite3StockBtreeCursorHasHint,
  .xBtreeTransferRow = sqlite3StockBtreeTransferRow,
  .xBtreeClearTableOfCursor = sqlite3StockBtreeClearTableOfCursor,
  .xBtreeCount = sqlite3StockBtreeCount,
};
static const BtreeMethods stock_btree_methods = {
  .pCsrMethods = &stock_btcursor_methods,
  .xBtreeCursor = sqlite3StockBtreeCursor,
  .xBtreeSeekCount = sqlite3StockBtreeSeekCount,
  .xBtreeLastPage = sqlite3StockBtreeLastPage,
  .xBtreeClose = sqlite3StockBtreeClose,
  .xBtreeSetCacheSize = sqlite3StockBtreeSetCacheSize,
  .xBtreeSetSpillSize = sqlite3StockBtreeSetSpillSize,
  .xBtreeSetMmapLimit = sqlite3StockBtreeSetMmapLimit,
  .xBtreeSetPagerFlags = sqlite3StockBtreeSetPagerFlags,
  .xBtreeSetPageSize = sqlite3StockBtreeSetPageSize,
  .xBtreeGetPageSize = sqlite3StockBtreeGetPageSize,
  .xBtreeGetReserveNoMutex = sqlite3StockBtreeGetReserveNoMutex,
  .xBtreeGetRequestedReserve = sqlite3StockBtreeGetRequestedReserve,
  .xBtreeMaxPageCount = sqlite3StockBtreeMaxPageCount,
  .xBtreeSecureDelete = sqlite3StockBtreeSecureDelete,
  .xBtreeSetAutoVacuum = sqlite3StockBtreeSetAutoVacuum,
  .xBtreeGetAutoVacuum = sqlite3StockBtreeGetAutoVacuum,
  .xBtreeNewDb = sqlite3StockBtreeNewDb,
  .xBtreeBeginTrans = sqlite3StockBtreeBeginTrans,
  .xBtreeIncrVacuum = sqlite3StockBtreeIncrVacuum,
  .xBtreeCommitPhaseOne = sqlite3StockBtreeCommitPhaseOne,
  .xBtreeCommitPhaseTwo = sqlite3StockBtreeCommitPhaseTwo,
  .xBtreeCommit = sqlite3StockBtreeCommit,
  .xBtreeTripAllCursors = sqlite3StockBtreeTripAllCursors,
  .xBtreeRollback = sqlite3StockBtreeRollback,
  .xBtreeBeginStmt = sqlite3StockBtreeBeginStmt,
  .xBtreeSavepoint = sqlite3StockBtreeSavepoint,
  .xBtreeCreateTable = sqlite3StockBtreeCreateTable,
  .xBtreeClearTable = sqlite3StockBtreeClearTable,
  .xBtreeDropTable = sqlite3StockBtreeDropTable,
  .xBtreeGetMeta = sqlite3StockBtreeGetMeta,
  .xBtreeUpdateMeta = sqlite3StockBtreeUpdateMeta,
  .xBtreePragma = sqlite3StockBtreePragma,
  .xBtreePager = sqlite3StockBtreePager,
  .xBtreeGetFilename = sqlite3StockBtreeGetFilename,
  .xBtreeGetJournalname = sqlite3StockBtreeGetJournalname,
  .xBtreeTxnState = sqlite3StockBtreeTxnState,
  .xBtreeIsInBackup = sqlite3StockBtreeIsInBackup,
  .xBtreeSchema = sqlite3StockBtreeSchema,
  .xBtreeSchemaLocked = sqlite3StockBtreeSchemaLocked,
  .xBtreeIsReadonly = sqlite3StockBtreeIsReadonly,
  .xBtreeSetVersion = sqlite3StockBtreeSetVersion,
  .xBtreeIntegrityCheck = sqlite3StockBtreeIntegrityCheck,
  .xBtreeCheckpoint = sqlite3StockBtreeCheckpoint,
  .xBtreeExclusiveLock = sqlite3StockBtreeExclusiveLock,
};

/*
** END OF GENERATED CODE
******************************************************************/
/* END_HCT_MKBTREEWRAPPER_TCL_CODE */

#ifdef SQLITE_DEBUG
sqlite3_uint64 sqlite3BtreeSeekCount(Btree *p){
  return p->pMethods->xBtreeSeekCount(p);
}
#endif

BtCursor *sqlite3BtreeFakeValidCursor(void){
  static BtCursor csr = {0};
  return &csr;
}

int sqlite3BtreeCursorSize(void){
  return MAX(
      sqlite3HctBtreeCursorSize(),
      sqlite3StockBtreeCursorSize()
  );
}

void sqlite3BtreeCursorZero(BtCursor *p){
  memset(p, 0, sqlite3BtreeCursorSize());
}

int sqlite3BtreeCursorHasMoved(BtCursor *pCur){
  if( pCur->pMethods==0 ) return 0;
  return pCur->pMethods->xBtreeCursorHasMoved(pCur);
}

int sqlite3BtreeCloseCursor(BtCursor *pCur){
  if( pCur->pMethods==0 ) return 0;
  return pCur->pMethods->xBtreeCloseCursor(pCur);
}

int sqlite3BtreeCursor(
  Btree *p,                                   /* The btree */
  Pgno iTable,                                /* Root page of table to open */
  int wrFlag,                                 /* 1 to write. 0 read-only */
  struct KeyInfo *pKeyInfo,                   /* First arg to xCompare() */
  BtCursor *pCur                              /* Write new cursor here */
){
  int rc = p->pMethods->xBtreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
  pCur->pMethods = p->pMethods->pCsrMethods;
  return rc;
}

static int btWrapperUseHct(
  sqlite3_vfs *pVfs, 
  const char *zFilename, 
  int *pbUseHct
){
  int rc = SQLITE_OK;
  char *zFull = 0;
  char *zPagemap = 0;
  int bUseHct = 0;

  if( zFilename && zFilename[0] ){
    int nAlloc = pVfs->mxPathname+2;
    int bExists = 0;

    zFull = (char*)sqlite3_malloc(nAlloc);
    if( zFull==0 ){
      rc = SQLITE_NOMEM_BKPT;
    }else{
      memset(zFull, 0, nAlloc);
      rc = pVfs->xFullPathname(pVfs, zFilename, pVfs->mxPathname, zFull);
    }

    if( rc==SQLITE_OK ){
      rc = pVfs->xAccess(pVfs, zFull, SQLITE_ACCESS_EXISTS, &bExists);
    }
    if( rc==SQLITE_OK ){
      zPagemap = sqlite3_mprintf("%s-pagemap", zFull);
      if( zPagemap==0 ){
        rc = SQLITE_NOMEM_BKPT;
      }else if( bExists ){
        rc = pVfs->xAccess(pVfs, zPagemap, SQLITE_ACCESS_EXISTS, &bUseHct);
      }else{
        sqlite3OsDelete(pVfs, zPagemap, 0);
        bUseHct = sqlite3_uri_boolean(zFilename, "hctree", 0);
      }
    }
  }

  sqlite3_free(zFull);
  sqlite3_free(zPagemap);
  *pbUseHct = bUseHct;
  return rc;
}

int sqlite3BtreeOpen(
  sqlite3_vfs *pVfs,      /* VFS to use for this b-tree */
  const char *zFilename,  /* Name of the file containing the BTree database */
  sqlite3 *db,            /* Associated database handle */
  Btree **ppBtree,        /* Pointer to new Btree object written here */
  int flags,              /* Options */
  int vfsFlags            /* Flags passed through to sqlite3_vfs.xOpen() */
){
  Btree *pBtree = 0;
  int rc = SQLITE_OK;
  int bUseHct = 0;

  rc = btWrapperUseHct(pVfs, zFilename, &bUseHct);
  if( rc==SQLITE_OK ){
    if( bUseHct ){
      rc = sqlite3HctBtreeOpen(pVfs, zFilename, db, &pBtree, flags, vfsFlags);
      if( rc==SQLITE_OK ) pBtree->pMethods = &hct_btree_methods;
    }else{
      rc = sqlite3StockBtreeOpen(pVfs, zFilename, db, &pBtree, flags, vfsFlags);
      if( rc==SQLITE_OK ) pBtree->pMethods = &stock_btree_methods;
    }
  }
  *ppBtree = pBtree;
  return rc;
}

int sqlite3IsHct(Btree *pBt){
  return (pBt && pBt->pMethods==&hct_btree_methods);
}

int sqlite3IsHctCsr(BtCursor *pCsr){
  return (pCsr && pCsr->pMethods==&hct_btcursor_methods);
}

int sqlite3BtreeSchemaLoaded(Btree *pBt){
  int rc = SQLITE_OK;
  if( sqlite3IsHct(pBt) ){
    rc = sqlite3HctBtreeSchemaLoaded(pBt);
  }
  return rc;
}


