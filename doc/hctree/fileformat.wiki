
  *   <a href=#overall>Overall Structure</a>
  *   <a href=#header>Header File Format</a>
  *   <a href=#pagemap>Page Map Format</a>
  *   <a href=#db>Database File Format</a>

<h1 id=overall> Overall Structure </h1>

Each database consists of at least three files:

  *  A database file, containing database file pages,
  *  A page-map file, containing the page-map, and
  *  A header file, containing the two header pages.

If the database is configured to be robust in the face of system or power
failures, there are three page-map files instead of one.

Additionally, there may be one or more client log files.

<h1 id=header> Header File Format </h1>

The header file consists of two pages using the same format.

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>0  <td>32 <td>Magic string identifying an hctree database.
  <tr><td>32 <td>8  <td>Checksum for header page.
  <tr><td>40 <td>4  <td>Constant Value 1234. To identify endianness of database.
  <tr><td>44 <td>4  <td>Page size in bytes.
  <tr><td>48 <td>8  <td>Guaranteed safe recovery transaction id.
</table>

<h1 id=pagemap> Page Map Format </h1>

Page-map slots 2-32, inclusive, are not used for a logical-to-physical page
mapping. Instead, the lower 32-bits of these slots are used as follows:

<table border=1 cellpadding=5 width=90%>
  <tr><th>Slot<th>Use 
  <tr><td>2   <td>Largest logical page number allocated in database.
  <tr><td>3   <td>Largest physical page number allocated in database.
</table>

<h1 id=db> Database File Format </h1>

Database pages are numbered starting from 1. Each database page is <i>pgsz</i>
bytes in size, where <i>pgsz</i> is determined by the value stored in the
header file.

There are 5 types of database page:

  *  Intkey Leaf Pages
  *  Intkey Internal Node Pages
  *  Index Leaf Pages
  *  Index Internal Node Pages
  *  Overflow Pages

All pages begin with an 8 byte page header:

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>0 <td>1 <td> Page type:
  *  0x01 - Intkey pages.
  *  0x02 - Index pages.
  *  0x03 - Overflow page. 
  <tr><td>1 <td>1 <td> Distance between list and leaves. For leaves, 0, for
                        parents of leaves, 1, and so on)
  <tr><td>2 <td>2 <td> Number of entries on page (<i>nEntry</i> below).
  <tr><td>4 <td>4 <td> Peer page number.
</table>

<h2 id=intkey_leaf> Intkey Leaf Page Format </h2>

Following the page header, the free-space header:

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>8 <td>2 <td> number of bytes of free space between the end of 
    header array and the first entry within the record area.
  <tr><td>10 <td>2 <td> number of bytes of free space (in total) within
    record area.
  <tr><td>12 <td>4 <td> Unused.
</table>

Following the free-space header, an array of <i>nEntry</i> 16-byte entries. 
Each 16-byte entry is comprised of the following:

  *  8-byte rowid value.
  *  4-byte record size (in bytes).
  *  2-byte record offset (from start of page).
  *  1-byte flags field. Flags are HAS_TID, HAS_OLD and HAS_OVFL.
  *  1-byte unused.

Each record within the record area consists of:

  *  If HAS_TID is set, an 8-byte transaction id.
  *  If HAS_OLD is set, a 4-byte "old" physical page number.
  *  If HAS_OVFL is set, a 4-byte overflow page number.
  *  The part of the record stored on the main page.

The part of the record stored on the main page is calculated using:

<verbatim>
        if( nRecord <= (pgsz-16-16-12) ){
          nLocal = nRecord;
        }else{ 
          nLocal = nRecord % (pgsz-8);
          if( nLocal < (pgsz/16) || nLocal > (pgsz-16-16-16) ){
            nLocal = pgsz/16;
          }
        }
</verbatim>

<h2> Intkey Internal Node Page Format </h2>

Each entry on an intkey internal node page consists of an 8 byte rowid and
a 4 byte page-id. Such a page may therefore contain up to <i>nMax</i> entries:

<verbatim>
        nMax = ((pgsz-8) / 12)
</verbatim>

The area immediately following the page header is divided into two arrays
of <i>nMax</i> entries each. The first is of 8-byte rowids, the second
of 4-byte page ids. Only the first <i>nEntry</i> entries in each array
are valid.

<h2> Overflow Page Format </h2>

As in SQLite, overflow pages are a linked list, starting with the page
identified in the b-tree page record. The number of overflow pages in
the linked list, and the amount of data on the last of them, may be inferred
from the record-size field on the b-tree page. The amount of data on each
page, in bytes, is also stored in the <i>nEntry</i> field of the overflow
page header.

<i style=color:green>Idea: Overflow pages do not need logical page numbers. All
pointers within the linked list, and the original page number on the b-tree
page could just be physical page numbers.</i>

<h2> Index Leaf Page Format </h2>

Index leaf pages have a free-space header immediately following the page
header. See the <a href=#intkey_leaf>intkey leaf page format</a> section for
details.

Immediately following the free-space header is an <i>nEntry</i> entry array
of 8-byte entries. Each entry consists of:

  *  A 4-byte record size value,
  *  A 2-byte record offset, and
  *  A 1-byte flags field (flags are HAS_TID, HAS_OLD and HAS_OVFL).

Each record within the record area consist of:

  *  If HAS_TID is set, an 8-byte transaction id.
  *  If HAS_OLD is set, a 4-byte "old" physical page number.
  *  If HAS_OVFL is set, a 4-byte overflow page number.
  *  The part of the record stored on the main page.

just as those on index leaf pages do. The part of the record stored on the
main page is calculated using:

<verbatim>
        if( nRecord <= (pgsz-16-8-12) ){
          nLocal = nRecord;
        }else{ 
          nLocal = nRecord % (pgsz-8);
          if( nLocal < (pgsz/16) || nLocal > (pgsz-16-8-16) ){
            nLocal = pgsz/16;
          }
        }
</verbatim>

<h2> Index Internal Node Page Format </h2>

As for index leaf pages, except that the <i>nEntry</i> array consists of
12-byte entries:

  *  A 4-byte record size value,
  *  A 4-byte child page number.
  *  A 2-byte record offset, and
  *  A 1-byte flags field (the only valid flag is HAS_OVFL).



