

<h1> Overall Structure </h1>

File format parameters:

  *  Page size. Default 4KiB. This must be a power of 2.
  *  Chunk size. Default 128K pages (1MB chunk-size, 512MB database file size
     per chunk). This must be a power of 2 greater than the page size.

The database file begins with a pair of header pages. Each header page is
the same size as every other page in the database.

Immediately following the header pages is the first page-map chunk, 
containing the first (chunksize/8) page-map entries. Following this,
the first (chunksize/8) database pages. Then another page-map chunk, and 
so on.

Physical pages are numbered starting from 1. Only database pages are assigned
numbers - the two header pages and the parts of the file used for page-map
chunks do not have page numbers. The offset of physical page iPg is therefore:

<verbatim>
  offset = (2 * pagesize) + (((iPg-1) / (chunksize/8)) * chunksize) + ((iPg-1) * pagesize)
</verbatim>

Page numbers 2-32, inclusive, are not used. Page 1 must be used, as SQLite
assumes it to be the root page of the sqlite_schema table.

The second element of the page-map (the unused logical page 2) is used to 
store the maximum assigned transaction id.

<h1> Header Pages </h1>

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>0  <td>32 <td>Magic string identifying an hctree database.
  <tr><td>32 <td>8  <td>Checksum for header page.
  <tr><td>40 <td>4  <td>Constant Value 1234. To identify endianness of database.
  <tr><td>44 <td>4  <td>Page size in bytes.
  <tr><td>48 <td>8  <td>Guaranteed safe recovery transaction id.
</table>

<h1> Database Page format </h1>

Each page begins with a 32-byte recovery header. Consisting of:

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>0 <td>8 <td> Checksum. Based on page content (including this header)
                       and <i>TODO</i>
  <tr><td>8 <td>8 <td>  Transaction id of transaction that wrote page.
  <tr><td>16 <td>8 <td> Largest transaction id ever to have written this
                        logical page.
  <tr><td>24 <td>4 <td> Logical page id for this page.
  <tr><td>28 <td>4 <td> Physical page id for previous page written by this
                        transaction (or 0 if this is the first).
</table>

Followed by an 8-byte page header:

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>36 <td>1 <td> Page type:
  *  0x01 - Intkey leaf pages.
  *  0x02 - Intkey internal node pages.
  *  0x03 - Index leaf pages.
  *  0x04 - Index internal node pages.
  *  0x05 - Overflow page. 
  <tr><td>37 <td>1 <td> Unused.
  <tr><td>38 <td>2 <td> Number of entries on page.
  <tr><td>40 <td>4 <td> Peer page number.
</table>

<h2> Intkey Leaf Pages </h2>

The keys for an intkey table are the concatenation of a 64-bit rowid and a
56-bit transaction id. 15 bytes in total. Associated with each key is an
N byte SQLite record blob of data.

The remaining page space is divided into three sections:

  *  An nEntry array of 16-byte key/flags entries. The first 15 bytes of
     the entry contains the key, the remaining 8 bits are used for flags.
     There are two flags defined - IS_DELETED and HAS_OVERFLOW.
  *  An nEntry array of 2-byte offsets. Offsets are relative to the start
     of the page. The first entry corresponds to the last byte of the
     first record, the last to the last byte of the last record.
  *  An nEntry array of tightly packed records. Each record consists of:
  <ul>
    <li> If IS_DELETED is set, the transaction id of the transaction that
         deleted the entry, encoded as an SQLite varint.
    <li> The part of the record stored on the main page.
    <li> If HAS_OVERFLOW is set, a 4 byte overflow page number.
  </ul>

The size of the part of the record stored on the main page is calculated as:

<verbatim>
        if( nRecord <= (pgsz-40-16-2-9) ){
          nLocal = nRecord;
        }else{ 
          nLocal = MIN(pgsz-40-16-2-9-4, MAX(pgsz/4, nRecord % (pgsz-40)))
        }
</verbatim>

The offset array may contain the special value 0 for the first key on the
page only. In this case there is no record associated with the key.
This happens when the record has been permanently deleted, but the key cannot
be deleted because it is the fencepost key.

<h2> Intkey Internal Node Pages </h2>

The remaining page space is divided into two sections:

  *  An nEntry array of 16-byte key/flags entries. The first 15 bytes of
     the entry contains the key.
  *  An nEntry array of 4-byte child page numbers.

<h2> Index Leaf Pages </h2>

The remaining page space is divided into two sections:

  *  An nEntry array of 8-byte transaction-id/flags fields. Used in the
     same way and with the same flags as the corresponding field on intkey
     pages.
  *  An nEntry array of 2-byte offsets. Offsets are relative to the start
     of the page. The first entry corresponds to the last byte of the
     first record, the last to the last byte of the last record.
  *  An nEntry array of tightly packed records. Each record consists of:
  <ul>
    <li> If IS_DELETED is set, the transaction id of the transaction that
         deleted the entry, encoded as an SQLite varint.
    <li> The part of the record stored on the main page.
    <li> If HAS_OVERFLOW is set, a 4 byte overflow page number.
  </ul>

The size of the part of the record stored on the main page is calculated as:

<verbatim>
        if( nRecord <= (pgsz/4) ){
          nLocal = nRecord;
        }else{ 
          nLocal = pgsz/4;
        }
</verbatim>

<h2> Index Internal Node Pages </h2>

Same format as index leaf pages, except that immediately following the
array of transaction-id/flags fields, there is:

  *  An nEntry array of 4-byte logical child page numbers.

The offset array may contain the special value 0 for the first key on the
page only. In this case there is no fencepost record associated with the 
child - the child page is the leftmost page in the tree.

<h2> Overflow pages </h2>

For an overflow page, the "peer node" field of the page header contains the
next page in the overflow list, or 0 if there is no next page. The nEntry
field is set to the number of bytes of data on the page following the page 
header.

<h1> Page-Map Format </h1>

