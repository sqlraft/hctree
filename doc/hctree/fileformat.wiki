
  *   [#overall | 1. Overall Structure]
  *   [#header  | 2. Header File Format]
  *   [#pagemap | 3. Page Map Format]
  *   [#db      | 4. Database File Format]
    <ul>
      <li>[#intkey_leaf | 4.1. Intkey Leaf Page Format]
      <li>[#intkey_node | 4.2. Intkey Internal Node Format]
      <li>[#index_leaf  | 4.3. Index Leaf Page Format]
      <li>[#index_node  | 4.4. Index Internal Node Format]
      <li>[#overflow    | 4.5. Overflow Chain Format]
    </ul>

<h1 id=overall>1. Overall Structure </h1>

Each database consists of at least three files:

  *  A database file, containing database file pages,
  *  A page-map file, containing the page-map, and
  *  A header file, containing the two header pages.

If the database is configured to be robust in the face of system or power
failures, there are three page-map files instead of one.

Additionally, there may be one or more client log files.

<h1 id=header> 2. Header File Format </h1>

The header file consists of two pages using the same format.

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>0  <td>32 <td>Magic string identifying an hctree database.
  <tr><td>32 <td>8  <td>Checksum for header page.
  <tr><td>40 <td>4  <td>Constant Value 1234. To identify endianness of database.
  <tr><td>44 <td>4  <td>Page size in bytes.
  <tr><td>48 <td>8  <td>Guaranteed safe recovery transaction id.
</table>

<h1 id=pagemap> 3. Page Map Format </h1>

Page-map slots 2-32, inclusive, are not used for a logical-to-physical page
mapping. Instead, the lower 32-bits of these slots are used as follows:

<table border=1 cellpadding=5 width=90%>
  <tr><th>Slot<th>Use 
  <tr><td>2   <td>Largest logical page number allocated in database.
  <tr><td>3   <td>Largest physical page number allocated in database.
</table>

<h1 id=db> 4. Database File Format </h1>

Database pages are numbered starting from 1. Each database page is <i>pgsz</i>
bytes in size, where <i>pgsz</i> is determined by the value stored in the
header file.

There are 5 types of database page:

  *  Intkey Leaf Pages
  *  Intkey Internal Node Pages
  *  Index Leaf Pages
  *  Index Internal Node Pages
  *  Overflow Pages

All pages begin with an 8 byte page header:

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>0 <td>1 <td> Page type:
  *  0x01 - Intkey pages.
  *  0x02 - Index pages.
  *  0x03 - Overflow page. 
  <tr><td>1 <td>1 <td> Distance between list and leaves. For leaves, 0, for
                        parents of leaves, 1, and so on)
  <tr><td>2 <td>2 <td> Number of entries on page (<i>nEntry</i> below).
  <tr><td>4 <td>4 <td> Peer page number.
</table>

<h2 id=intkey_leaf> 4.1. Intkey Leaf Page Format</h2>
Intkey leaf page format:

<verbatim type="pikchr center">
boxht=0.2 ; boxwid=0.6 ; linewid=0.2

# total width is 7.5
PGHDR: box "page hdr"        wid 0.8
LEHDR: box "leaf hdr"        wid 1.0
ARRAY:box "entry array"      wid 1.2
box "free space"             wid 1.5
box "record area"            wid 3.0

text "8 bytes" at PGHDR - (0, 0.2)
text "24 bytes" at LEHDR - (0, 0.2)
text "nEntry x 16 bytes" at ARRAY - (0, 0.2)
</verbatim>

Following the page header, the 24 byte intkey leaf header:

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>8 <td>2 <td> number of bytes of free space between the end of 
    header array and the first entry within the record area (the region
    marked "free space" in the diagram above).
  <tr><td>10 <td>2 <td> number of bytes of free space (in total) within
    record area.
  <tr><td>12 <td>2 <td> Number of delete keys on page.
  <tr><td>14 <td>2 <td> Bytes of space consumed by delete keys.
  <tr><td>16 <td>8 <td> EDKS TID value, if any. Or 0 otherwise.
  <tr><td>24 <td>4 <td> Physical page number of EDKS root, if any. Or 0
    otherwise.
  <tr><td>28 <td>4 <td> Unused.
</table>

Following the free-space header, an array of <i>nEntry</i> 16-byte entries. 
Each 16-byte entry is comprised of the following:

  *  8-byte rowid value.
  *  4-byte record size (in bytes).
  *  2-byte record offset (from start of page).
  *  1-byte flags field. Flags are HAS_TID, HAS_OLD, HAS_OVFL and IS_DELETE.
  *  1-byte unused.

Each record within the record area consists of:

  *  If HAS_TID is set, an 8-byte transaction id.
  *  If HAS_OLD is set, a 4-byte "old" physical page number.
  *  If HAS_OVFL is set, a 4-byte physical overflow page number.
  *  The part of the record stored on the main page.

The part of the record stored on the main page is calculated using:

<verbatim>
        if( nRecord <= (pgsz-32-16-12) ){
          nLocal = nRecord;
        }else{ 
          nLocal = nRecord % (pgsz-8);
          if( nLocal < (pgsz/16) || nLocal > (pgsz-32-16-12-4) ){
            nLocal = pgsz/16;
          }
        }
</verbatim>


<h2 id=intkey_node> 4.2. Intkey Internal Node Format </h2>

<verbatim type="pikchr center">
boxht=0.2 ; boxwid=0.6 ; linewid=0.2

# total width is 7.5
PGHDR: box "page hdr"        wid 0.8
ARRAY:box "entry array"      wid 4.2
box "free space"             wid 2.5

text "8 bytes" at PGHDR - (0, 0.2)
text "nEntry x 16 bytes" at ARRAY - (0, 0.2)
</verbatim>

Each entry on an intkey internal node page consists of an 8 byte rowid 
followed by a 4 byte logical page-id, and is padded out to 16 bytes.
The maximum number of entries on an intkey internal node page is
therefore:

<verbatim>
        nMax = ((pgsz-8) / 16)
</verbatim>

<h2 id=index_leaf> 4.3. Index Leaf Page Format </h2>

<verbatim type="pikchr center">
boxht=0.2 ; boxwid=0.6 ; linewid=0.2

# total width is 7.5
PGHDR: box "page hdr"        wid 0.8
LEHDR: box "leaf hdr"        wid 1.0
ARRAY:box "entry array"      wid 1.2
box "free space"             wid 1.5
box "record area"            wid 3.0

text "8 bytes" at PGHDR - (0, 0.2)
text "24 bytes" at LEHDR - (0, 0.2)
text "nEntry x 8 bytes" at ARRAY - (0, 0.2)
</verbatim>

Index leaf pages have a 24 byte leaf header immediately following the page
header. See the <a href=#intkey_leaf>intkey leaf page format</a> section for
details.

Immediately following the free-space header is an <i>nEntry</i> entry array
of 8-byte entries. Each entry consists of:

  *  A 4-byte record size value,
  *  A 2-byte record offset, and
  *  A 1-byte flags field (flags are HAS_TID, HAS_OLD and HAS_OVFL).

Each record within the record area consist of:

  *  If HAS_TID is set, an 8-byte transaction id.
  *  If HAS_OLD is set, a 4-byte "old" physical page number.
  *  If HAS_OVFL is set, a 4-byte overflow page number.
  *  The part of the record stored on the main page.

just as those on intkey leaf pages do. The part of the record stored on the
main page is calculated using:

<verbatim>
        if( nRecord <= (pgsz-16-8-12) ){
          nLocal = nRecord;
        }else{ 
          nLocal = nRecord % (pgsz-8);
          if( nLocal < (pgsz/16) || nLocal > (pgsz-16-8-16) ){
            nLocal = pgsz/16;
          }
        }
</verbatim>


<h2 id=index_node> 4.4. Index Internal Node Page Format </h2>

<verbatim type="pikchr center">
boxht=0.2 ; boxwid=0.6 ; linewid=0.2

# total width is 7.5
PGHDR: box "page hdr"        wid 0.8
INHDR: box "i-n hdr"         wid 0.6
ARRAY:box "entry array"      wid 1.2
box "free space"             wid 1.5
box "record area"            wid 3.4

text "8 bytes" at PGHDR - (0, 0.2)
text "4 bytes" at INHDR - (0, 0.2)
text "nEntry x 12 bytes" at ARRAY - (0, 0.2)
</verbatim>

<table border=1 cellpadding=5 width=90%>
  <tr><th>Byte Offset <th>Size <th width=80%> Description
  <tr><td>8 <td>2 <td> number of bytes of free space between the end of 
    header array and the first entry within the record area (the region
    marked "free space" in the diagram above).
  <tr><td>10 <td>2 <td> number of bytes of free space (in total) within
    record area.
</table>

As for index leaf pages, except that the <i>nEntry</i> array consists of
12-byte entries:

  *  A 4-byte record size value,
  *  A 4-byte child page number.
  *  A 2-byte record offset, and
  *  A 1-byte flags field (the only valid flag is HAS_OVFL).

<h2 id=overflow> 4.5. Overflow Chain Format </h2>

<verbatim type="pikchr center">
boxht=0.2 ; boxwid=0.6 ; linewid=0.2

PGHDR: box "page hdr"        wid 0.8
DATA: box "data"             wid 4.7
box "free space"             wid 2.0

text "8 bytes" at PGHDR - (0, 0.2)
text "nEntry bytes" at DATA - (0, 0.2)
</verbatim>

As in SQLite, overflow pages are a linked list, starting with the page
identified in the b-tree page record. The number of overflow pages in
the linked list, and the amount of data on the last of them, may be inferred
from the record-size field on the b-tree page. The amount of data on each
page, in bytes, is also stored in the <i>nEntry</i> field of the overflow
page header.

Overflow pages are identified by physical page only - both the page number
embedded in the start of the record within the tree structure page and the
"next page" page number on overflow pages themselves are physical, not 
logical, page numbers



