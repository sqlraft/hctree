# 2021 June 1
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
# This file implements regression tests for SQLite library.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix hct_conflict2


proc do_sql_test {db tn sql {res {0 {}}} } {
  uplevel [subst {
    do_test $tn {
      catchsql { $sql } $db
    } {$res}
  }]
}

hct_reset_db
sqlite3 db2 test.db

do_execsql_test 1.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
  INSERT INTO t1 VALUES(1, 'i');
  INSERT INTO t1 VALUES(2, 'ii');
  INSERT INTO t1 VALUES(3, 'iii');
}

proc func {} { 
  db2 eval $::func_sql
  set ::func_sql ""
  return 1 
}
db func func func

set ::func_sql {
  UPDATE t1 SET b='two' WHERE a=2
}

do_catchsql_test 1.1 {
  UPDATE t1 SET b=a WHERE func();
} {1 {database is locked}}

do_test 1.2 {
  sqlite3_extended_errcode db
} {SQLITE_BUSY_SNAPSHOT}

do_execsql_test 1.3 {
  SELECT * FROM t1
} {1 i 2 two 3 iii}

db2 close
#--------------------------------------------------------------------------

hct_reset_db
sqlite3 db2 test.db


do_sql_test db  2.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
  INSERT INTO t1 VALUES(1, 'i');
  INSERT INTO t1 VALUES(2, 'ii');
  INSERT INTO t1 VALUES(3, 'iii');
}

do_sql_test db2 2.1 {
  BEGIN CONCURRENT;
    UPDATE t1 SET b=a+1;
}

do_sql_test db 2.2 { DELETE FROM t1 WHERE a=2 }

do_sql_test db2 2.3 {
  COMMIT
} {1 {database is locked}}

foreach {tn sql} {
  1 COMMIT
  2 "SELECT * FROM t1"
  3 "INSERT INTO t1 VALUES(10, 'ten')"
} {
  do_sql_test db2 2.4.$tn $sql {1 {database is locked}}
}
db2 eval ROLLBACK
db2 close


#--------------------------------------------------------------------------

hct_reset_db
sqlite3 db2 test.db


do_sql_test db 3.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
  INSERT INTO t1 VALUES(1, 'i');
  INSERT INTO t1 VALUES(2, 'ii');
  INSERT INTO t1 VALUES(3, 'iii');
}

do_sql_test db 3.1 {
  BEGIN;
    INSERT INTO t1 VALUES(5, 'v');
  ROLLBACK;
}

do_sql_test db2 3.2 {
  INSERT INTO t1 VALUES(4, 'iv');
}

do_sql_test db 3.3 {
  SELECT * FROM t1
} {0 {1 i 2 ii 3 iii 4 iv}}

#--------------------------------------------------------------------------
hct_reset_db
do_execsql_test 4.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  INSERT INTO t1 
  VALUES(5, 'five'), (10, 'ten'), (15, 'fifteen'), (20, 'twenty');
}

sqlite3 db2 test.db

do_test 4.1 {
  db eval {
    BEGIN CONCURRENT;
      SELECT * FROM t1 WHERE a=5;
  }

  db2 eval {
    INSERT INTO t1 VALUES(17, 'seventeen');
    DELETE FROM t1 WHERE a=17;
  }

  catchsql {
      INSERT INTO t1 VALUES(17, 'seventeen+');
    COMMIT;
  }
} {1 {database is locked}}

db2 close

#-------------------------------------------------------------------------
hct_reset_db
do_execsql_test 5.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  INSERT INTO t1 
  VALUES(5, 'five'), (10, 'ten'), (15, 'fifteen'), (20, 'twenty');
}

sqlite3 db2 test.db

do_test 5.1 {
  db eval {
    BEGIN;
      UPDATE t1 SET b='fifteen+' WHERE a=15;
  }

  db2 eval {
    UPDATE t1 SET b='' WHERE a=15;
    DELETE FROM t1 WHERE a=15;
  }

  catchsql {
    COMMIT;
  }
} {1 {database is locked}}

#-------------------------------------------------------------------------
hct_reset_db
do_execsql_test 6.0 {
  PRAGMA page_size = 512;
  CREATE TABLE jobs(
    jobID       INTEGER NOT NULL PRIMARY KEY,
    parentJobID INTEGER NOT NULL DEFAULT 0,
    state TEXT NOT NULL
  );
  CREATE INDEX jobs_idx ON jobs(parentJobID, state) WHERE parentJobID!=0;

  INSERT INTO jobs VALUES
      (1, 0, 'QUEUED'),
       (2, 1, 'QUEUED'),
       (3, 1, 'QUEUED'),
       (4, 1, 'QUEUED'),
      (5, 0, 'QUEUED'),
       (6, 5, 'QUEUED'),
       (7, 5, 'FINISHED'),
       (8, 5, 'QUEUED'),
      (9, 0, 'QUEUED'),
       (10, 9, 'QUEUED'),
       (11, 9, 'QUEUED'),
       (12, 9, 'QUEUED');
}

sqlite3 db2 test.db

do_execsql_test -db db 6.1 {
  BEGIN CONCURRENT;
    UPDATE jobs SET state = 'FINISHED' WHERE jobId=6;
    SELECT jobId FROM jobs 
      WHERE parentJobID!=0 AND parentJobID=5 AND 
      state IN ('QUEUED', 'RUNQUEUED', 'RUNNING', 'PAUSED')
      LIMIT 1
} {8}

do_execsql_test -db db2 6.2 {
  BEGIN CONCURRENT;
    UPDATE jobs SET state = 'FINISHED' WHERE jobId=8;
    SELECT jobId FROM jobs 
      WHERE parentJobID!=0 AND parentJobID=5 AND 
      state IN ('QUEUED', 'RUNQUEUED', 'RUNNING', 'PAUSED')
      LIMIT 1
} {6}

do_execsql_test -db db  6.3 { COMMIT }
do_test 6.4 {
  catchsql COMMIT db2
} {1 {database is locked}}
catch { db2 eval ROLLBACK }

do_execsql_test 6.4 {
  DELETE FROM jobs;
  INSERT INTO jobs VALUES
      (1, 0, 'QUEUED'),
       (2, 1, 'QUEUED'),
       (3, 1, 'QUEUED'),
       (4, 1, 'QUEUED'),
      (5, 0, 'QUEUED'),
       (860, 5, 'QUEUED'),
       (7, 5, 'FINISHED'),
       (900, 5, 'QUEUED'),
      (9, 0, 'QUEUED'),
       (862, 9, 'QUEUED'),
       (863, 9, 'QUEUED'),
       (864, 9, 'QUEUED');
}

do_execsql_test -db db 6.5 {
  BEGIN CONCURRENT;
    UPDATE jobs SET state = 'FINISHED' WHERE jobId=860;
    SELECT jobId FROM jobs 
      WHERE parentJobID!=0 AND parentJobID=5 AND 
      state IN ('QUEUED', 'RUNQUEUED', 'RUNNING', 'PAUSED')
      LIMIT 1
} {900}

do_execsql_test -db db2 6.6 {
  BEGIN CONCURRENT;
    UPDATE jobs SET state = 'FINISHED' WHERE jobId=900;
    SELECT jobId FROM jobs 
      WHERE parentJobID!=0 AND parentJobID=5 AND 
      state IN ('QUEUED', 'RUNQUEUED', 'RUNNING', 'PAUSED')
      LIMIT 1
} {860}

do_execsql_test -db db  6.7 { COMMIT }
do_test 6.8 {
  catchsql COMMIT db2
} {1 {database is locked}}
db2 eval ROLLBACK

do_execsql_test 6.9 {
  DELETE FROM jobs;
  INSERT INTO jobs VALUES
     (134695745, 0, 'QUEUED'),
       (677689728, 134695745, 'QUEUED'),
       (3831388500, 134695745, 'QUEUED'),
       (4146526905, 134695745, 'QUEUED');
}

do_execsql_test -db db 6.9.1 {
  UPDATE jobs SET state='FINISHED' WHERE jobid=677689728;
  BEGIN CONCURRENT;
    UPDATE jobs SET state='FINISHED' WHERE jobid=4146526905;
    SELECT jobId FROM jobs 
      WHERE parentJobID!=0 AND parentJobID=134695745 AND 
      state = 'QUEUED'
      LIMIT 1
} {3831388500}

do_execsql_test -db db2 6.9.2 {
  BEGIN CONCURRENT;
    UPDATE jobs SET state='FINISHED' WHERE jobid=3831388500;
    SELECT jobId FROM jobs 
      WHERE parentJobID!=0 AND parentJobID=134695745 AND 
      state = 'QUEUED'
      LIMIT 1
} {4146526905}

do_execsql_test -db db 6.9.3 {
  COMMIT
}

do_test 6.9.4 {
  catchsql COMMIT db2
} {1 {database is locked}}
catchsql ROLLBACK db2

do_execsql_test 6.9.5 {
  SELECT * FROM jobs
} {
  134695745 0 QUEUED 
  677689728 134695745 FINISHED 
  3831388500 134695745 QUEUED
  4146526905 134695745 FINISHED
}


#----------------

do_execsql_test 6.10 {
  DELETE FROM jobs;
  INSERT INTO jobs VALUES
     (134695745, 0, 'QUEUED'),
       (677689728, 134695745, 'QUEUED'),
       (3831388500, 134695745, 'QUEUED'),
       (4146526905, 134695745, 'QUEUED');
}

do_execsql_test -db db 6.10.1 {
  UPDATE jobs SET state='FINISHED' WHERE jobid=677689728;
  BEGIN CONCURRENT;
    UPDATE jobs SET state='FINISHED' WHERE jobid=3831388500;
    SELECT jobId FROM jobs 
      WHERE parentJobID!=0 AND parentJobID=134695745 AND 
      state = 'QUEUED'
      LIMIT 1
} {4146526905}

do_execsql_test -db db2 6.10.2 {
  BEGIN CONCURRENT;
    UPDATE jobs SET state='FINISHED' WHERE jobid=4146526905;
    SELECT jobId FROM jobs 
      WHERE parentJobID!=0 AND parentJobID=134695745 AND 
      state = 'QUEUED'
      LIMIT 1
} {3831388500}

do_execsql_test -db db 6.10.3 {
  COMMIT
}

do_test 6.10.4 {
  catchsql COMMIT db2
} {1 {database is locked}}
catchsql ROLLBACK db2

do_execsql_test 6.9.5 {
  SELECT * FROM jobs
} {
  134695745  0 QUEUED 
  677689728  134695745 FINISHED 
  3831388500 134695745 FINISHED
  4146526905 134695745 QUEUED
}

finish_test


