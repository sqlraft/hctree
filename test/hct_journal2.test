# 2023 May 17
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix hct_journal2

proc catch_hct_journal_init {db} {
  set rc [sqlite3_hct_journal_init db]
  if {$rc!="SQLITE_OK"} {
    return [list 1 [sqlite3_errmsg db]]
  }
  return "0 {}"
}

hct_reset_db
catch_hct_journal_init db

proc validate {iCid zSchema data schema_version} {
  return $::validate_ret
}

sqlite3_hct_journal_validation_hook db validate

set ::validate_ret 0
do_execsql_test 1.0 {
  CREATE TABLE t1(x, y);
}


do_execsql_test 1.1 {
  INSERT INTO t1 VALUES(1, 2);
}

set ::validate_ret 1
do_catchsql_test 1.2 {
  INSERT INTO t1 VALUES(3, 4);
} {1 {database is locked}}

do_execsql_test 1.3 {
  SELECT cid, schema, hct_journal_entry(data) FROM sqlite_hct_journal
} {
  7 {CREATE TABLE t1(x, y);} {}
  8 {} {t1: ins 1/(1,2)}
  9 {} {}
}

set ::validate_ret 0
do_execsql_test 1.4 {
  INSERT INTO t1 VALUES(5, 6);
}

do_execsql_test 1.5 {
  SELECT cid, schema, hct_journal_entry(data) FROM sqlite_hct_journal
} {
  7 {CREATE TABLE t1(x, y);} {}
  8 {} {t1: ins 1/(1,2)}
  9 {} {}
  10 {} {t1: ins 2/(5,6)}
}

set ::validate_ret 1
do_catchsql_test 1.6 {
  CREATE TABLE t2(a, b);
} {1 {database is locked}}

do_execsql_test 1.7 {
  SELECT cid, schema, hct_journal_entry(data),
    schema_version = lag(schema_version) OVER (ORDER BY cid)
  FROM sqlite_hct_journal
} {
  7 {CREATE TABLE t1(x, y);} {}   {}
  8 {} {t1: ins 1/(1,2)}           1
  9 {} {}                          1
  10 {} {t1: ins 2/(5,6)}          1
  11 {} {}                         1
}

set ::validate_ret 0
do_execsql_test 1.8 {
  CREATE INDEX t1i ON t1(x);
  INSERT INTO t1 VALUES(7, 8);
  ALTER TABLE t1 ADD COLUMN z;
}

do_execsql_test 1.9 {
  SELECT cid, schema, hct_journal_entry(data),
    schema_version = lag(schema_version) OVER (ORDER BY cid)
  FROM sqlite_hct_journal
} {
  7 {CREATE TABLE t1(x, y);} {}        {}
  8 {} {t1: ins 1/(1,2)}               1
  9 {} {}                              1
  10 {} {t1: ins 2/(5,6)}              1
  11 {} {}                             1
  12 {CREATE INDEX t1i ON t1(x);}   {} 0
  13 {} {t1: ins 3/(7,8)}              1
  14 {ALTER TABLE t1 ADD COLUMN z;} {} 0
}

sqlite3 db2 test.db
do_execsql_test -db db2 1.10 {
  SELECT * FROM t1
} {1 2 {}  5 6 {}  7 8 {}}

proc validate {iCid zSchema data schema_version} {
breakpoint
  catch { db2 eval COMMIT }
  return 1
}

db2 eval {
  BEGIN CONCURRENT;
    INSERT INTO t1 VALUES('x', 'y', 'z');
}

do_catchsql_test 1.11 {
  CREATE TABLE t3(a, b);
} {1 {database is locked}}

  
do_execsql_test 1.12 {
  SELECT cid, schema, hct_journal_entry(data),
    schema_version = lag(schema_version) OVER (ORDER BY cid)
  FROM sqlite_hct_journal WHERE cid>=14
} {
  14 {ALTER TABLE t1 ADD COLUMN z;} {} {}
  15 {} {} 1
  16 {} {} 1
}

execsql_pp {
  SELECT cid, schema, hct_journal_entry(data), quote(schema_version) FROM sqlite_hct_journal
}


finish_test

