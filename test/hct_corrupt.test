# 2025 July 30
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
source $testdir/hct_common.tcl
set testprefix hct_corrupt

hct_reset_db

# Given logical page number $lpgno, return the logical child page number
# of the leftmost child. Or, if $lpgno is a leaf page, return an empty
# string.
#
proc hct_leftmost_child {db lpgno} {
 
  $db one {
    SELECT hctentry.child 
    FROM hctpgmap, hctdb, hctentry 
    WHERE hctpgmap.slot=$lpgno AND 
      hctdb.pgno=hctpgmap.value AND 
      hctentry.pgno=hctpgmap.value AND 
      hctentry.entry=0
  }
  
}

# Given logical page number $lpgno, return the logical peer page number.
# This is 0 if there is no peer.
#
proc hct_peer {db lpgno} {
  $db one {
    SELECT hctdb.peer 
    FROM hctdb, hctpgmap
    WHERE hctpgmap.slot=$lpgno AND hctdb.pgno=hctpgmap.value
  }
}


# Parameter tname must be the name of an intkey table in hct database db.
# This function returns the offset within the database of the overflow
# page pointer of the row with integer key $ikey. Or, if there is no
# such entry, throws an error.
#
proc hct_ovfl_offset {db tname ikey} {
  set root [$db one {SELECT rootpage FROM sqlite_schema WHERE name=$tname}]
  if {$root==""} { error "no such table: $tname" }

  # Find the logical page number of the leftmost leaf in the table.
  set leaf $root
  while {[set child [hct_leftmost_child $db $leaf]]!=""} {
    set leaf $child
  }

  # Set lLeaf to a list of logical page numbers that are leaves of this table
  set peer $leaf
  set lLeaf [list $peer]
  while {[set peer [hct_peer $db $peer]]!=0} {
    lappend lLeaf $peer
  }

  # Search each leaf page for the specified $ikey value.
  $db eval "
    SELECT 
    hctentry.pgno AS pgno, 
           hctentry.entry AS entry,
           hctentry.tid AS tid,
           hctentry.rangetid AS rangetid,
           hctentry.rangeoldpg AS rangeoldpg,
           hctentry.ovfl AS ovfl,
           hctentry.offset AS offset
    FROM hctpgmap, hctentry
    WHERE hctpgmap.slot IN ([join $lLeaf ,]) AND 
      hctentry.pgno=hctpgmap.value AND
      (hctentry.ikey=:ikey OR (hctentry.ikey IS NULL AND hctentry.record GLOB :ikey))
  " {
    if {$ovfl==""} {
      error "row $tname/$ikey does not have an overflow chain"
    }
    set ret $offset
    if {$tid!=""} { incr ret 8 }
    if {$rangetid!=""} { incr ret 8 }
    if {$rangeoldpg!=""} { incr ret 4 }
    return [expr ($pgno-1)*4096 + $ret]
  }

  error "row $tname/$ikey could not be found"
}

proc hct_set_mapping {fname iLogical iPhysical} {
  set mapfile "$fname-pagemap"
  set offset [expr ($iLogical-1)*8] 
  set bin [binary decode hex [hexio_read $mapfile $offset 8]]
  binary scan $bin m val

  set val [expr ($val & (255<<56)) | $iPhysical]
  set hex [binary encode hex [binary format m $val]]
  hexio_write $mapfile $offset $hex
}

#-------------------------------------------------------------------------
# Test a bad overflow page number.
#
do_execsql_test 1.0 {
  CREATE TABLE t1(x INTEGER PRIMARY KEY, y);
  INSERT INTO t1 VALUES(1000, hex(randomblob(4000)));
}

do_execsql_test 1.1.1 {
  SELECT value FROM hctpgmap WHERE slot=33
} {9}
do_execsql_test 1.1.2 {
  SELECT offset, tid, ovfl FROM hctentry WHERE pgno=9
} {168 2 8}
do_execsql_test 1.1.3 {
  PRAGMA page_size
} {4096}
do_execsql_test 1.1.4 {
  SELECT length(+y) FROM t1;
} {8000}

hct_copy_db test.db test.db2
sqlite3 db2 test.db2
do_execsql_test -db db2 1.2 {
  SELECT length(+y) FROM t1
} 8000
db2 close

do_test 1.3 {
  set ovfl [hct_ovfl_offset db t1 1000]
  hct_copy_db test.db test.db2
  hexio_write test.db2 $ovfl 00FFFF00
  sqlite3 db2 test.db2
  set res [catchsql { SELECT length(+y) FROM t1 } db2]
  db2 close
  set res
} {1 {database disk image is malformed}}

#-------------------------------------------------------------------------
# Map logical page 2 (the meta-data table) to an out-of-range physical 
# page.
#
hct_reset_db
do_execsql_test 2.0 {
  CREATE TABLE t1(x INTEGER PRIMARY KEY, y);
  INSERT INTO t1 VALUES(1000, hex(randomblob(4000)));
}

foreach {tn val} {1 0   2 1234   3 10000000   4 0   5 -1} {
  hct_set_mapping test.db 2 $val
  do_test 2.1.$tn {
    catchsql { SELECT * FROM t1 }
  } {1 {database disk image is malformed}}
}

hct_reset_db
do_execsql_test 2.2.0 {
  CREATE TABLE t1(x INTEGER PRIMARY KEY, y);
  INSERT INTO t1 VALUES(1000, hex(randomblob(4000)));
}

do_execsql_test 2.2.1 {
  BEGIN CONCURRENT;
    INSERT INTO t1 VALUES(2000, 'heyheyhey');
}

sqlite3 db2 test.db
do_execsql_test -db db2 2.2.2 {
  INSERT INTO t1 VALUES(0, 'zero');
}
hct_set_mapping test.db 2 4523

do_catchsql_test 2.2.3 {
  COMMIT
} {1 {database disk image is malformed}}

#-------------------------------------------------------------------------
# Cause an error when clearing a direct-write table.
#
hct_reset_db
do_execsql_test 3.0 {
  CREATE TABLE t1(a);
  BEGIN;
    CREATE TABLE t2(b);
    SAVEPOINT abc;
      INSERT INTO t2 VALUES( hex(randomblob(400)) );
      INSERT INTO t2 VALUES( hex(randomblob(400)) );
      INSERT INTO t2 VALUES( hex(randomblob(400)) );
      INSERT INTO t2 VALUES( hex(randomblob(400)) );
  SELECT rootpage FROM sqlite_schema WHERE name='t2';
} {34}

hct_set_mapping test.db 34 45235

do_catchsql_test 3.1 {
  ROLLBACK TO abc;
} {1 {database disk image is malformed}}

db close
sqlite3 db test.db

do_execsql_test 3.2 {
  SELECT * FROM sqlite_schema;
} {
  table t1 t1 33 {CREATE TABLE t1(a)}
}

#-------------------------------------------------------------------------
# Cause an error when clearing a direct-write table.
#
hct_reset_db
do_execsql_test 3.0 {
  CREATE TABLE t1(a);
  BEGIN;
    CREATE TABLE t2(a INTEGER PRIMARY KEY, b) WITHOUT ROWID;
    INSERT INTO t2 VALUES(10, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(20, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(30, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(40, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(50, hex(randomblob(2500)) );
  COMMIT;
} {}

#show_pagemap
#show_all_entries

do_test 3.1 {
  set ovfl [hct_ovfl_offset db t2 (50,*]
  hct_copy_db test.db test.db2
  hexio_write test.db2 $ovfl 00FFFF00
  sqlite3 db2 test.db2

  catchsql {
    INSERT INTO t2 VALUES(5, 'hello world');
  } db2
} {1 {database disk image is malformed}}

#-------------------------------------------------------------------------
# Cause an error when searching a fan-page.
#
hct_reset_db

do_execsql_test 4.0 {
  CREATE TABLE t1(a);
  BEGIN;
    CREATE TABLE t2(a INTEGER PRIMARY KEY, b) WITHOUT ROWID;
    INSERT INTO t2 VALUES(10, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(20, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(30, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(40, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(50, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(60, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(70, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(80, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(90, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(100, hex(randomblob(2500)) );
    INSERT INTO t2 VALUES(110, hex(randomblob(2500)) );
  COMMIT;
} {}

sqlite3 db2 test.db

do_execsql_test -db db2 4.1 {
  BEGIN;
    SELECT a FROM t2
} {10 20 30 40 50 60 70 80 90 100 110}

for {set ii 0} {1} {incr ii} {
  do_test 4.2.$ii.1 {
    hct_copy_db test.db test.db2
    sqlite3 db2 test.db2
    db2 eval {
      BEGIN;
        SELECT a FROM t2;
    }
  } {10 20 30 40 50 60 70 80 90 100 110}

  sqlite3 db3 test.db2
  db3 eval {
    DELETE FROM t2 WHERE a>10
  }
  db3 eval {SELECT pgno, nentry FROM hctdb WHERE pgtype='history'} { }

  do_test 4.2.$ii.2 {execsql {SELECT length(b) FROM t2 WHERE a=110} db2} {5000}
  do_test 4.2.$ii.3 {execsql {SELECT length(b) FROM t2 WHERE a=60} db2} {5000}
  do_test 4.2.$ii.4 {execsql {SELECT length(b) FROM t2 WHERE a=90} db2} {5000}
  do_test 4.2.$ii.5 {execsql {SELECT length(b) FROM t2 WHERE a=80} db2} {5000}
  do_test 4.2.$ii.6 {execsql {SELECT length(b) FROM t2 WHERE a=70} db2} {5000}
  do_test 4.2.$ii.7 {execsql {SELECT length(b) FROM t2 WHERE a=60} db2} {5000}
  do_test 4.2.$ii.8 {execsql {SELECT length(b) FROM t2 WHERE a=50} db2} {5000}
  do_test 4.2.$ii.9 {execsql {SELECT length(b) FROM t2 WHERE a=40} db2} {5000}
  do_test 4.2.$ii.10 {execsql {SELECT length(b) FROM t2 WHERE a=30} db2} {5000}
  do_test 4.2.$ii.11 {execsql {SELECT length(b) FROM t2 WHERE a=20} db2} {5000}
  do_test 4.2.$ii.12 {execsql {SELECT length(b) FROM t2 WHERE a=10} db2} {5000}

  if {$ii>=($nentry-1)} break

  # pgno is the physical page number of the fan page. Trash the ($ii+1)th
  # pointer on that page.
  if {$ii==0} {
    set offset [expr ($pgno-1)*4096 + 8 + 8+8]
  } else {
    set offset [expr ($pgno-1)*4096 + 8 + 32 + ($ii-1)*4]
  }
  hexio_write test.db2 $offset 00FFFF00
  # if {$ii==0} { execsql_pp { SELECT * FROM hctentry } db2 }

  do_test 4.2.$ii.13 {
    catchsql {
      SELECT * FROM t2 WHERE a=10;
      SELECT * FROM t2 WHERE a=20;
      SELECT * FROM t2 WHERE a=30;
      SELECT * FROM t2 WHERE a=40;
      SELECT * FROM t2 WHERE a=50;
      SELECT * FROM t2 WHERE a=60;
      SELECT * FROM t2 WHERE a=70;
      SELECT * FROM t2 WHERE a=80;
      SELECT * FROM t2 WHERE a=90;
      SELECT * FROM t2 WHERE a=100;
      SELECT * FROM t2 WHERE a=110;
    } db2
  } {1 {database disk image is malformed}}

  do_test 4.2.$ii.14 {
    catchsql {
      SELECT * FROM t2;
    } db2
  } {1 {database disk image is malformed}}

  db2 close
  db3 close
}

hct_copy_db test.db test.db2
sqlite3 db2 test.db2
sqlite3 db3 test.db2

do_test 4.3.1 {
  db2 eval {
    BEGIN;
      SELECT a FROM t2;
  }
} {10 20 30 40 50 60 70 80 90 100 110}

do_test 4.3.2 {
  db3 eval {
    DELETE FROM t2 WHERE a>10
  }
} {}

do_test 4.3.2 {

  # Trash the overflow pointers that might be required by the fan-search.
  #
  foreach k [db eval {SELECT a FROM t2}] {
    set ovfl [hct_ovfl_offset db t2 ($k,*]
    hexio_write test.db2 $ovfl 00FFFF00
  }

  catchsql {
    SELECT * FROM t2 WHERE a=110
  } db2
} {1 {database disk image is malformed}}

#-------------------------------------------------------------------------
#
hct_reset_db
do_execsql_test 5.0 {
  BEGIN;
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b) WITHOUT ROWID;
    INSERT INTO t1 VALUES(10, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(20, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(30, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(40, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(50, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(60, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(70, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(80, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(90, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(100, hex(randomblob(2500)) );
    INSERT INTO t1 VALUES(110, hex(randomblob(2500)) );
  COMMIT;
} {}

do_execsql_test 5.1 {
  SELECT a FROM t1 ORDER BY a DESC, b DESC;
} {
  110 100 90 80 70 60 50 40 30 20 10
}

foreach k [db eval {SELECT a FROM t1}] {
  hct_copy_db test.db test.db2
  sqlite3 db2 test.db2
  do_test 5.2.$k {
    set res [list [catch {
      db2 eval { SELECT a FROM t1 ORDER BY a DESC } {
        if {$a==$k} {
          set ovfl [hct_ovfl_offset db2 t1 ($k,*]
          hexio_write test.db2 $ovfl 00FFFF00
        }
      }
    } msg] $msg]
    
    if {$res=="0 {}"} {
      set res {1 {database disk image is malformed}}
    }
    set res
  } {1 {database disk image is malformed}}

  db2 close 
}


foreach k [db eval {SELECT a FROM t1}] {
  lappend lOvfl [hct_ovfl_offset db t1 ($k,*]
}
foreach ovfl $lOvfl {
  hexio_write test.db $ovfl 00FFFF00
}
do_catchsql_test 5.3 {
  SELECT a FROM t1 ORDER BY a DESC, b DESC;
} {1 {database disk image is malformed}}

finish_test

