# 2021 June 1
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
# This file implements regression tests for SQLite library.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix hct_update1

proc show_db_entries {} {
  execsql_pp {
    SELECT slot, pgno, ikey, tid, rangetid, rangeoldpg 
      FROM hctentry, hctpgmap 
      WHERE slot>=33 AND logical_in_use AND pgno=value;
  }
}

hct_reset_db
sqlite3 db2 test.db

do_execsql_test 1.0 {
  CREATE TABLE t1(x INTEGER PRIMARY KEY, t TEXT);
  INSERT INTO t1 VALUES(1, 'one');
  INSERT INTO t1 VALUES(2, 'two');
  INSERT INTO t1 VALUES(3, 'three');
  INSERT INTO t1 VALUES(4, 'four');
  INSERT INTO t1 VALUES(5, 'five');
  INSERT INTO t1 VALUES(6, 'six');
}

do_execsql_test -db db2 1.1 {
  BEGIN;
    SELECT * FROM t1;
} {
  1 one 2 two 3 three 4 four 5 five 6 six
}

do_execsql_test 1.2 {
  UPDATE t1 SET t='TWO' WHERE x=2
}

do_execsql_test -db db2 1.3.1 {
  SELECT * FROM t1;
} {
  1 one 2 two 3 three 4 four 5 five 6 six
}
do_execsql_test -db db2 1.3.2 {
  SELECT * FROM t1 ORDER BY 1 DESC;
} {
  6 six 5 five 4 four 3 three 2 two 1 one 
}

do_execsql_test 1.4 {
  UPDATE t1 SET t='THREE' WHERE x=3
}

do_execsql_test -db db2 1.5.1 {
  SELECT * FROM t1;
} {
  1 one 2 two 3 three 4 four 5 five 6 six
}
do_execsql_test -db db2 1.5.2 {
  SELECT * FROM t1 ORDER BY 1 DESC;
} {
  6 six 5 five 4 four 3 three 2 two 1 one 
}

do_execsql_test -db db2 1.5.3 {
  SELECT * FROM t1 WHERE x=3
} {
  3 three
}

#--------------------------------------------------------------------------


proc data_check {tn db data} {
  do_execsql_test -db $db $tn.asc {
    SELECT a, b FROM t1 ORDER BY 1
  } $data

  set data2 [list]
  foreach {a b} $data { set data2 [concat $a $b $data2] }
  do_execsql_test -db $db $tn.desc {
    SELECT a, b FROM t1 ORDER BY 1 DESC
  } $data2

if 1 {
  foreach {a b} $data {
    do_execsql_test -db $db $tn.$a " 
      SELECT a, b FROM t1 WHERE a=$a 
    " [list $a $b]
  }
  }
}

foreach {tn dlist} {
  1 {12 15}
  2 { {12 15} }
  3 { {12 13} }
  4 { 10 9 8 7 6 5 4 3 2 }
  5 { 1 }
  6 { 30 }
  7 { 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 }
  8 { {1 3 5 7 9 11 13 15 17 19 21 23 25 27 29} }

  9  { 12 13 }

  10 { 12 13 14 15 16 17 18 }
  11 { {14} {15 16} }
  12 { {1 2 3} {4 5 6} }
  13 { {1 2 3} {4 5 6 7 8 9 10 11 12 13} 
       {14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30} 
     }
  14 { {1 2 3} {5 6 7} 4 }
} {
  hct_reset_db
  sqlite3 db2 test.db

  do_execsql_test 2.$tn.1 {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b CHAR(10));
    WITH s(i) AS (
      SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<30
    )
    INSERT INTO t1 SELECT i, hex(randomblob(5)) FROM s;
  }

  db2 eval BEGIN
  set data  [db2 eval {SELECT a, b FROM t1 ORDER BY 1}]

  set tn2 1
  foreach d $dlist {
    execsql "UPDATE t1 SET b=hex(randomblob(5)) WHERE a IN ([join $d ,])"

    data_check 2.$tn.2.$tn2 db2 $data

    incr tn2
  }
}

foreach {tn dlist} {
  1 {100 900}
} {
  hct_reset_db
  sqlite3 db2 test.db

  do_execsql_test 3.$tn.1 {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b CHAR(10));
    WITH s(i) AS (
      SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<1000
    )
    INSERT INTO t1 SELECT i, hex(randomblob(50)) FROM s;
  }

  db2 eval BEGIN
  set data [db2 eval {SELECT a, b FROM t1 ORDER BY 1}]

  set tn2 1
  foreach {a b} $dlist {
    execsql "UPDATE t1 SET b=hex(randomblob(5)) WHERE a BETWEEN $a AND $b"

    data_check 3.$tn.2.$tn2 db2 $data

    incr tn2
  }

}

#show_db_entries

foreach {tn dlist} {
  1 {1-4 +3}
  2 {1-10 +1 +2 +3 +4 +5 +8}
  3 {1-100 +50}
  4 {30-30 +30 30-30 +30 30-30 +30}
} {
  hct_reset_db
  sqlite3 db2 test.db

  do_execsql_test 4.$tn.1 {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b CHAR(10));
    WITH s(i) AS (
      SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<6
    )
    INSERT INTO t1 SELECT i, hex(randomblob(50)) FROM s;
  }

  db2 eval BEGIN
  set data [db2 eval {SELECT a, b FROM t1 ORDER BY 1}]
  set data2 [db2 eval {SELECT a, b FROM t1 ORDER BY 1 DESC}]

  set d1 [db2 eval {SELECT a FROM t1 ORDER BY 1}]
  set d2 [db2 eval {SELECT a FROM t1 ORDER BY 1 DESC}]

  set tn2 1
  foreach {cmd} $dlist {
    if {[regexp {([0-9]+)-([0-9]+)} $cmd -> a b]} {
      execsql "UPDATE t1 SET b=hex(randomblob(50)) WHERE a BETWEEN $a AND $b"
    } elseif {[regexp {\+([0-9]+)} $cmd -> a]} {
      execsql "REPLACE INTO t1 VALUES($a, hex(randomblob(10)))"
    } else {
      error "unrecognized: $cmd"
    }

    data_check 4.$tn.2.$tn db2 $data

    incr tn2
  }
}


finish_test

