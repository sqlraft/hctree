# 2025 July 26
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
source $testdir/hct_common.tcl
set testprefix hct_journal_misc

#-------------------------------------------------------------------------
# Test some misc. cases in sqlite3_hct_journal_init():
#
#   1.1: sqlite3_hct_journal_init() where the hct_journal table exists but
#        has the wrong schema.
#
#   1.2: Multiple calls to sqlite3_hct_journal_init() on the same db.
#
#   1.3: The invocation of "PRAGMA hct_ndbfile" used by hct_journal_init() to
#        determine whether or not the db is an hct db is SQLITE_DENY by the
#        authorizer callback.
#
hct_reset_db

do_execsql_test 1.0 {
  CREATE TABLE hct_journal(a, b, c);
}
do_test 1.1 {
  catch_hct_journal_init db
} {1 {no such column: cid}}

hct_reset_db

do_test 1.2 {
  catch_hct_journal_init db
  catch_hct_journal_init db
  catch_hct_journal_init db
} {0 {}}

proc myauth {a b c d e} {
  if {$a=="SQLITE_PRAGMA" && $b=="hct_ndbfile"} {
    return "SQLITE_DENY"
  }
  return "SQLITE_OK"
}

hct_reset_db
db auth myauth

do_test 1.3 {
  catch_hct_journal_init db
} {1 {not authorized}}

#-------------------------------------------------------------------------
hct_reset_db
catch_hct_journal_init db
sqlite3_hct_journal_setmode db LEADER
do_test 2.0 {
  hct_write_leader db { CREATE TABLE t1(a INTEGER PRIMARY KEY, b) }
  hct_write_leader db { INSERT INTO t1 VALUES(1, 'one') }
  hct_write_leader db { INSERT INTO t1 VALUES(2, 'two') }
  hct_write_leader db { INSERT INTO t1 VALUES(3, 'three') }
  hct_write_leader db { INSERT INTO t1 VALUES(5, 'five') }
  hct_write_leader db { INSERT INTO t1 VALUES(7, 'seven') }
} {SQLITE_OK 7 2}

sqlite3_hct_journal_setmode db NORMAL
do_execsql_test 2.1.1 {
  UPDATE hct_journal SET cid = cid + 10_000_000;
}
sqlite3_hct_journal_setmode db LEADER
do_test 2.1.2 {
  hct_write_leader db { INSERT INTO t1 VALUES(11, 'eleven') }
} {SQLITE_OK 10000008 10000007}

sqlite3_hct_journal_setmode db NORMAL
do_execsql_test 2.2.1 {
  UPDATE hct_journal SET cid = cid + 3_000_000_000;
}
sqlite3_hct_journal_setmode db LEADER
do_test 2.2.2 {
  hct_write_leader db { INSERT INTO t1 VALUES(13, 'thirteen') }
} {SQLITE_OK 3010000009 3010000008}

sqlite3_hct_journal_setmode db NORMAL
do_execsql_test 2.2.1 {
  UPDATE hct_journal SET cid = cid + 300_000_000_000_000;
}
sqlite3_hct_journal_setmode db LEADER
do_test 2.2.2 {
  hct_write_leader db { INSERT INTO t1 VALUES(17, 'seventeen') }
} {SQLITE_OK 300003010000010 300003010000009}

# execsql_pp { SELECT cid, snapshot, query FROM hct_journal }

#-------------------------------------------------------------------------
hct_reset_db

do_execsql_test 3.0 {
  CREATE TABLE y1(x);
}

do_test 3.1 {
  list [catch { sqlite3_hct_journal_snapshot db } msg] $msg
} {1 {SQLITE_ERROR - not a FOLLOWER mode db}}

reset_db
do_test 3.2 {
  sqlite3_hct_journal_mode db
} {-1}

#-------------------------------------------------------------------------
hct_reset_db
catch_hct_journal_init db

do_execsql_test 4.0 { 
  CREATE TABLE t1(a, b); 
}

set ::myauth_deny ""
proc myauth {a b c d e} {
  if {$::myauth_deny!="" && $::myauth_deny==$b} {
    return "SQLITE_DENY"
  }
  return "SQLITE_OK"
}
db auth myauth

do_test 4.1 {
  set ::myauth_deny sqlite_schema
  sqlite3_hct_journal_setmode db LEADER
} {SQLITE_AUTH}

do_test 4.2 {
  set ::myauth_deny hct_journal
  sqlite3_hct_journal_setmode db LEADER
} {SQLITE_AUTH}


finish_test

