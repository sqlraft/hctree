# 2022 November 16
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
# This file implements regression tests for SQLite library.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix hct_thread2

# Setup for logging 
db close
sqlite3_shutdown
sqlite_log_to_stdout

hct_reset_db
# db eval { PRAGMA journal_mode = wal }

do_execsql_test 1.0 {
  CREATE TABLE vals(
    ii INTEGER PRIMARY KEY,
    topic INTEGER,
    value INTEGER
  );
  CREATE INDEX vals1 ON vals(topic, value);

  INSERT INTO vals VALUES(1, 1, 1);
  INSERT INTO vals VALUES(2, 1, 1);
  INSERT INTO vals VALUES(3, 1, 1);
  INSERT INTO vals VALUES(4, 1, 1);
  INSERT INTO vals VALUES(5, 1, 1);
  INSERT INTO vals VALUES(6, 1, 1);
  INSERT INTO vals VALUES(7, 1, 1);
  INSERT INTO vals VALUES(8, 1, 1);
}

proc program {bOdd nMs} {
  return [string map [list %BODD% $bOdd %NMS% $nMs] {
    sqlite3 dbX test.db

    set iRow 0
    set lVal [list 1 1 1 1]
    set C($lVal) 1

    set end_of_time [expr [clock_milliseconds] + %NMS%]

    while {[clock_milliseconds]<$end_of_time} {
      dbX eval { BEGIN CONCURRENT }
      set r [expr {($iRow+1)*2 - %BODD%}]

      set lVal [dbX eval {
        SELECT value+($r==ii) FROM vals WHERE (ii%2)=%BODD% ORDER BY ii
      }]
      dbX eval { UPDATE vals SET value=value+1 WHERE ii=$r }

      set iRow [expr {($iRow+1)%[llength $lVal]}]

      set rc [catch { dbX eval COMMIT }]
      if {$rc==0} {
        set C($lVal) 1
      } else {
        dbX eval ROLLBACK
      }
    }

    dbX close
    array get C
  }]
}

proc reader_program {nMs} {
  return [string map [list %NMS% $nMs %TESTDIR% $::testdir] {
    sqlite3 db test.db

    source %TESTDIR%/hct_common.tcl

    set end_of_time [expr [clock_milliseconds] + %NMS%]

    while {[clock_milliseconds]<$end_of_time} {
      db eval BEGIN
      set lVal [db eval {
        SELECT ii, topic, value 
        FROM vals 
        WHERE topic=1 
        ORDER BY ii ASC
      }]

      set lData [list \
        [lindex $lVal 2] \
        [lindex $lVal 8] \
        [lindex $lVal 14] \
        [lindex $lVal 20] \
        [lindex $lVal 5] \
        [lindex $lVal 11] \
        [lindex $lVal 17] \
        [lindex $lVal 23] \
      ]

      set C($lData) 1
      db eval ROLLBACK
    }

    array names C
  }]
}


set nMs 500

set hct_extra_write_logging 1
set prg1 [program 1 $nMs]
sqlthread spawn r1 $prg1

set prg2 [program 0 $nMs]
sqlthread spawn r2 $prg2

set rdr [reader_program $nMs]
sqlthread spawn r3 $rdr

do_test "1.1.(running threads for ${nMs} ms)" {
  if {[info exists r1]==0} { vwait r1 }
  if {[info exists r2]==0} { vwait r2 }
  if {[info exists r3]==0} { vwait r3 }
} {}
set hct_extra_write_logging 0


array set C1 $r1
array set C2 $r2

do_test "1.2.([llength $r3] selects)" {
  foreach res $r3 {
    set o1 [lrange $res 0 3]
    set o2 [lrange $res 4 7]
    if {[info exist C1($o1)]==0} { error "read invalid odds $o1" }
    if {[info exist C2($o2)]==0} { error "read invalid evens $o2" }
    # puts "valid read $res"
  }
} {}

#show_pagemap
#show_all_entries


finish_test

