# 2022 November 16
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
# This file implements regression tests for SQLite library.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix hct_thread2

# Setup for logging 
db close
sqlite3_shutdown
#sqlite_log_to_stdout

expr srand(0)

hct_reset_db

do_execsql_test 1.0 {
  CREATE TABLE jobs(
    jobID       INTEGER NOT NULL PRIMARY KEY,
    parentJobID INTEGER NOT NULL DEFAULT 0,
    state TEXT NOT NULL
  );
  CREATE INDEX jobs_idx ON jobs(parentJobID, state) WHERE parentJobID!=0;
}

# Possible text values for jobs.state column
#
set lStateVal { FINISHED QUEUED RUNQUEUED RUNNING PAUSED }

# Each thread does:
#
#   1. Open transaction.
#
#   2. Select at random a child job to work on. Any child job with a state
#     other than 'FINISHED' can be worked on. If no child job found, 
#     close transaction and restart at 1.
#
#   3. Check parent job is not 'FINISHED'. If it is, this is an error.
#
#   4. Set child job state to a randomly selected state.
#
#   5. If that state is FINISHED, check if there are any other children of
#      same parent with state set to anything other than FINISHED. If there
#      are not, (a) set parent to FINISHED, (b) add a new parent and its 
#      child jobs. All new jobs entries are set to QUEUED state. jobid values
#      are assigned randomly.
#
#   6. Commit transaction.
#
proc program {nMs} {
  return [string map [list %UTIL% [program_util] %NMS% $nMs] {
    %UTIL% 

    set lStateVal { FINISHED QUEUED RUNQUEUED RUNNING PAUSED }

    sqlite3 dbX test.db

    set end_of_time [expr [clock_milliseconds] + %NMS%]
    set nFinish 0

    while {[clock_milliseconds]<$end_of_time} {

      # Step 1:
      if {0==[sqlite3_get_autocommit dbX]} {
        error autocommit
      }

      dbX eval { BEGIN CONCURRENT }

      # Step 2:
      set lJob [dbX eval {
        SELECT jobID FROM jobs WHERE parentJobID!=0 AND state!='FINISHED'
      }]
      set iChildJob [lindex $lJob [rand 0 [expr {[llength $lJob]-1}]]]
      if {$iChildJob==""} {
        dbX eval ROLLBACK
        after 1
        continue
      }

      # Step 3:
      set iParentJob [dbX one {
        SELECT parentJobID FROM jobs WHERE jobID=$iChildJob
      }]
      set parent_state [dbX one {
        SELECT state FROM jobs WHERE jobID=$iParentJob
      }]
      if {$parent_state=="FINISHED" || $parent_state==""} {
        dbX eval END
        error "error! - child job is $iChildJob, parent ($iParentJob) is $parent_state"
      }

      # Step 4:
      set new_state [lindex $lStateVal [rand 0 4]]
      dbX eval {
        UPDATE jobs SET state = $new_state WHERE jobID = $iChildJob
      }

      # Step 5:
      if {$new_state == "FINISHED"} {
        set bFinished 1
        dbX eval {
          SELECT 1 FROM jobs 
          WHERE parentJobID!=0 AND parentJobID=$iParentJob AND
            state IN ('QUEUED', 'RUNQUEUED', 'RUNNING', 'PAUSED')
          LIMIT 1
        } {
          set bFinished 0
        }
        if {$bFinished} {
          dbX eval {
            UPDATE jobs SET state = 'FINISHED' WHERE jobID = $iParentJob
          }

          insert_job dbX

          if {($nFinish % 10)==0} {
            dbX eval { DELETE FROM jobs WHERE state='FINISHED' }
          }
        }

        incr nFinish 1
      }

      # Step 6:
      catch { dbX eval COMMIT }
      catch { dbX eval ROLLBACK }

    }

    dbX close
    array get C
  }]
}

proc program_util {} {
  return {
    proc insert_job {db} {
      set iParent [rand 0 10000000000]
      $db eval { INSERT INTO jobs VALUES($iParent, 0, 'QUEUED'); }
      set iParent [$db last_insert_rowid]
      for {set ii 0} {$ii < 3} {incr ii} {
        set iChild [rand 0 10000000000]
        $db eval { INSERT INTO jobs VALUES($iChild, $iParent, 'QUEUED'); }
      }
    }
    
    proc rand {min max} {
      expr {$min + int(abs(rand() * (1 + $max - $min)))}
    }
  }
}

eval [program_util]

db eval BEGIN
  insert_job db
  insert_job db
  insert_job db
  insert_job db
db eval COMMIT

set nMs 5000

set prg1 [program $nMs]
sqlthread spawn r1 $prg1
sqlthread spawn r2 $prg1

# catch { eval [program 500] } r1

do_test "1.1.(running threads for ${nMs} ms)" {
  if {[info exists r1]==0} { vwait r1 }
  if {[info exists r2]==0} { vwait r2 }
} {}
puts "r1: $r1"

do_test 1.2 { set ::r1 } {}
do_test 1.3 { set ::r2 } {}

# execsql_pp { SELECT * FROM jobs }


#show_pagemap
#show_all_entries


finish_test

