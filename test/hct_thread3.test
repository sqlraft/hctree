# 2022 November 16
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
# This file implements regression tests for SQLite library.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix hct_thread3

# Setup for logging 
#db close
#sqlite3_shutdown
#sqlite_log_to_stdout

expr srand(0)
#set hct_extra_write_logging 1

hct_reset_db

do_execsql_test 1.0 {
  PRAGMA page_size = 512;
  CREATE TABLE jobs(
    jobID       INTEGER NOT NULL PRIMARY KEY,
    parentJobID INTEGER NOT NULL DEFAULT 0,
    state TEXT NOT NULL
  );
  CREATE INDEX jobs_idx ON jobs(parentJobID, state) WHERE parentJobID!=0;
}

# Possible text values for jobs.state column
#
set lStateVal { FINISHED QUEUED RUNQUEUED RUNNING PAUSED }

# Each thread does:
#
#   1. Open transaction.
#
#   2. Select at random a child job to work on. Any child job with a state
#     other than 'FINISHED' can be worked on. If no child job found, 
#     close transaction and restart at 1.
#
#   3. Check parent job is not 'FINISHED'. If it is, this is an error.
#
#   4. Set child job state to a randomly selected state.
#
#   5. If that state is FINISHED, check if there are any other children of
#      same parent with state set to anything other than FINISHED. If there
#      are not, (a) set parent to FINISHED, (b) add a new parent and its 
#      child jobs. All new jobs entries are set to QUEUED state. jobid values
#      are assigned randomly.
#
#   6. Commit transaction.
#
proc program {nMs} {
  return [string map [list %UTIL% [program_util] %NMS% $nMs] {
    %UTIL% 

    set lStateVal { FINISHED QUEUED RUNQUEUED RUNNING PAUSED }

    sqlite3 dbX test.db

    set end_of_time [expr [clock_milliseconds] + %NMS%]
    set nFinish 0

    while {[clock_milliseconds]<$end_of_time} {

      # Step 1:
      if {0==[sqlite3_get_autocommit dbX]} {
        error autocommit
      }

      dbX eval { BEGIN CONCURRENT }

      # Step 2:
      set lJob [dbX eval {
        SELECT jobID FROM jobs WHERE parentJobID!=0 AND state!='FINISHED'
      }]
      set iChildJob [lindex $lJob [rand 0 [expr {[llength $lJob]-1}]]]
      if {$iChildJob==""} {
        dbX eval ROLLBACK
        after 1
        continue
      }

      dbX eval {
        SELECT c.jobID AS cj, p.jobId AS pj
        FROM jobs AS c, jobs AS p 
        WHERE c.parentJobId!=0 AND c.state!='FINISHED' 
          AND p.jobId=c.parentJobID AND p.state=='FINISHED'
      } {
        error "child job is $cj, but parent job $pj is FINISHED"
      }
      dbX eval {SELECT * FROM jobs}

      # Step 3:
      set iParentJob [dbX one {
        SELECT parentJobID FROM jobs WHERE jobID=$iChildJob
      }]

      set parent_state [dbX one {
        SELECT state FROM jobs WHERE jobID=$iParentJob
      }]

      if {$parent_state=="FINISHED" || $parent_state==""} {
        puts "ERROR: child job is $iChildJob, parent ($iParentJob) is $parent_state"
      set parent_state2 [dbX one {
        SELECT state FROM jobs WHERE jobID=$iParentJob
      }]
      puts "parent state 2: $parent_state2"

        dbX eval END
        error "child job is $iChildJob, parent ($iParentJob) is $parent_state"
      }

      # Step 4:
      set new_state [lindex $lStateVal [rand 0 4]]
      dbX eval {
        UPDATE jobs SET state = $new_state WHERE jobID = $iChildJob
      }

      # Step 5:
      if {$new_state == "FINISHED"} {
        set bFinished 1
        dbX eval {
          SELECT 1 FROM jobs 
          WHERE parentJobID!=0 AND parentJobID=$iParentJob AND
            state IN ('QUEUED', 'RUNQUEUED', 'RUNNING', 'PAUSED')
          LIMIT 1
        } {
          set bFinished 0
        }
        if {$bFinished} {
          set lUnfinished [dbX eval {
            SELECT jobID FROM jobs 
            WHERE state!='FINISHED' AND parentJobID=$iParentJob
          }]
          if {[llength $lUnfinished]} {
            execsql_pp {SELECT * FROM jobs} dbX
            execsql_pp {PRAGMA integrity_check} dbX
            puts ----
set hct_extra_logging 1
execsql_pp "PRAGMA vdbe_trace = 1" dbX
            execsql_pp "
              SELECT 1 FROM jobs 
                WHERE parentJobID!=0 AND parentJobID=$iParentJob AND
                state IN ('QUEUED', 'RUNQUEUED', 'RUNNING', 'PAUSED')
              LIMIT 1
            " dbX
execsql_pp "PRAGMA vdbe_trace = 0" dbX
set hct_extra_logging 0
            puts ----
            execsql_pp ROLLBACK dbX
            puts "Unfinished children of $iParentJob: $lUnfinished"
            execsql_pp "
              SELECT jobid FROM jobs 
                WHERE parentJobID!=0 AND parentJobID=$iParentJob AND
                state IN ('QUEUED', 'RUNQUEUED', 'RUNNING', 'PAUSED')
            " dbX
            puts ----

            puts "Unfinished children of $iParentJob: $lUnfinished"
            exit -1
            error "Unfinished children of $iParentJob: $lUnfinished"
          }

          dbX eval {
            UPDATE jobs SET state = 'FINISHED' WHERE jobID = $iParentJob
          }
          insert_job dbX
          if {($nFinish % 10)==0} {
            dbX eval { DELETE FROM jobs WHERE state='FINISHED' }
          }
        }

        incr nFinish 1
      }

      # Step 6:
      set rb [catch { dbX eval COMMIT }]
      catch { dbX eval ROLLBACK }
    }

    dbX close
    set nFinish
  }]
}

proc program_util {} {
  return {
    proc insert_job {db} {
      set iParent [rand 0 10000000000]
      $db eval { INSERT INTO jobs VALUES($iParent, 0, 'QUEUED'); }
      set iParent [$db last_insert_rowid]
      for {set ii 0} {$ii < 3} {incr ii} {
        set iChild [rand 0 10000000000]
        $db eval { INSERT INTO jobs VALUES($iChild, $iParent, 'QUEUED'); }
      }
    }
    
    proc rand {min max} {
      expr {$min + int(abs(rand() * (1 + $max - $min)))}
    }
proc execsql_pp {sql {db db}} {
  set nCol 0
  $db eval $sql A {
    if {$nCol==0} {
      set nCol [llength $A(*)]
      foreach c $A(*) { 
        set aWidth($c) [string length $c] 
        lappend data $c
      }
    }
    foreach c $A(*) { 
      set n [string length $A($c)]
      if {$n > $aWidth($c)} {
        set aWidth($c) $n
      }
      lappend data $A($c)
    }
  }
  if {$nCol>0} {
    set nTotal 0
    foreach e [array names aWidth] { incr nTotal $aWidth($e) }
    incr nTotal [expr ($nCol-1) * 3]
    incr nTotal 4

    set fmt ""
    foreach c $A(*) { 
      lappend fmt "% -$aWidth($c)s"
    }
    set fmt "| [join $fmt { | }] |"
    
    puts [string repeat - $nTotal]
    for {set i 0} {$i < [llength $data]} {incr i $nCol} {
      set vals [lrange $data $i [expr $i+$nCol-1]]
      puts [format $fmt {*}$vals]
      if {$i==0} { puts [string repeat - $nTotal] }
    }
    puts [string repeat - $nTotal]
  }
}
  }
}

eval [program_util]

set nInitialJob 2

db eval BEGIN
for {set ii 0} {$ii < $nInitialJob} {incr ii} {
  insert_job db
}
db eval COMMIT

set nMs [expr 5000]
set nThread 8

set prg1 [program $nMs]
for {set ii 0} {$ii<$nThread} {incr ii} {
  sqlthread spawn TH($ii) $prg1
}

do_test "1.1.(running threads for ${nMs} ms)" {
  for {set ii 0} {$ii<$nThread} {incr ii} {
    if {[info exists TH($ii)]==0} { vwait TH($ii) }
  }
} {}

for {set ii 0} {$ii<$nThread} {incr ii} {
  do_test 1.2.$ii { 
    set res $TH($ii)
    if {[string is integer -strict $::res]} { set res "" }
    set res
  } {}
}

if { [set_test_counter errors] } {
  execsql_pp { SELECT * FROM jobs }
  show_pagemap
  show_all_entries
}


finish_test

