# 2020 December 30
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
# This file implements regression tests for SQLite library.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix hct_mvcc2

array set T1 [list]
set nRange 200
set nTSize 10
set nRep   1000
set nVal   500

expr srand(0)

proc random_int {nRange} {
  expr int(rand()*$nRange)
}
proc random_val {nMax} {
  set bDel [expr int(rand()*4)==0]
  if {$bDel} { return "" }
  set nText [expr int(rand()*$nMax)+1]
  return [string range [string repeat "x$nText." $nText] 0 [expr $nText-1]]
}

foreach {tn ct} {
  1 { CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT) }
  2 { CREATE TABLE t1(a INT, b TEXT, PRIMARY KEY(a)) WITHOUT ROWID }
} {

reset_db
do_execsql_test $tn.0 $ct
sqlite3 db2 test.db
catch { array unset T1 }

for {set i 0} {$i < $nRep} {incr i} {
  array unset a
  array unset b

  for {set x 0} {$x < $nTSize} {incr x} {
    set a([random_int $nRange]) [random_val $nVal]
    set b([random_int $nRange]) [random_val $nVal]
  }

  foreach x [array names a] {
    if {$a($x)=="" && [info exists T1($x)]==0} { unset a($x) }
  }
  foreach x [array names b] {
    if {$b($x)=="" && [info exists T1($x)]==0} { unset b($x) }
  }

  set pp_b [list]
  foreach x [array names b] { 
    lappend pp_b $x [string range $b($x) 0 9] 
  }
  set pp_a [list]
  foreach x [array names a] { 
    lappend pp_a $x [string range $a($x) 0 9] 
  }

  set bConflict 0
  foreach x [array names a] {
    if {[info exists b($x)]} { set bConflict 1 }
  }

  do_test $tn.1.$i.1 {
    execsql BEGIN
    foreach k [array names a] {
      set v $a($k) 
      if {$v==""} {
        #puts "1: DELETE FROM t1 WHERE a=$k "
        execsql { DELETE FROM t1 WHERE a=$k }
      } else {
        #puts "1: REPLACE INTO t1 VALUES($k, $v) "
        execsql { REPLACE INTO t1 VALUES($k, $v) }
      }
    }
  } {}

  #integrity_check $tn.1.$i.1a

if {0 && $tn==2 && $i==($nRep-1)} {
execsql_pp { SELECT * FROM hctpgmap natural join hctdb }
execsql_pp { SELECT * FROM hctpgmap natural join hctentry }
breakpoint
}

  do_test $tn.1.$i.2 {
    execsql BEGIN db2
    foreach k [array names b] {
      set v $b($k) 
      if {$v==""} {
        #puts "2: DELETE FROM t1 WHERE a=$k "
        execsql { DELETE FROM t1 WHERE a=$k } db2
      } else {
        #puts "2: REPLACE INTO t1 VALUES($k, [string range $v 0 12]..) "
        execsql { REPLACE INTO t1 VALUES($k, $v) } db2
      }
    }
    execsql COMMIT db2
  } {}

if {$tn==2 && $i==0} {
  puts "a: [lsort -integer [array names a]]"
  puts "b: [lsort -integer [array names b]]"
  puts "bConflict=$bConflict"
  breakpoint
}
  if {$bConflict} {
    do_catchsql_test $tn.1.$i.3a {
      COMMIT
    } {1 {database is locked}}
    execsql ROLLBACK
  } else {
    do_catchsql_test $tn.1.$i.3b {
      COMMIT
    } {0 {}}
  }

if {0 && $tn==2 && $i==($nRep-1)} {
  execsql_pp { SELECT * FROM hctpgmap natural join hctdb }
  execsql_pp { SELECT * FROM hctpgmap natural join hctentry }
}

  foreach x [array names b] {
    if {$b($x)==""} {
      unset -nocomplain T1($x)
    } else {
      set T1($x) $b($x)
    }
  }
  if {$bConflict==0} {
    foreach x [array names a] {
      if {$a($x)==""} {
        unset -nocomplain T1($x)
      } else {
        set T1($x) $a($x)
      }
    }
  }

  set res [list]
  foreach x [lsort -integer [array names T1]] {
    lappend res $x $T1($x)
  }
  do_execsql_test $tn.1.$i.4 { SELECT * FROM t1 ORDER BY a } $res

  set res [list]
  foreach x [lsort -integer [array names T1]] {
    lappend res $x
  }
  do_execsql_test $tn.1.$i.5 {
    SELECT a FROM t1 ORDER BY a
  } $res
}

}


finish_test

